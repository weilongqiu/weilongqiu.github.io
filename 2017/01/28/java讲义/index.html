<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="第3章 数据类型和运算符java是一门强类型的语言，所有的变量必须先声明、后使用，从而保证程序更加健壮，可以在编译过程中发现源代码的错误。
3.2 标识符和关键字第4章 流程控制与数组4.5 数组类型4.5.1 理解数组：数组也是一种类型所有的数组具有相同的数据类型。
int[]也是一种数据类型，它本身是一种引用类型，可以使用该类型定义变量，也可以使用该类型进行类型转换。创建int[]类型的对象也">
<meta property="og:type" content="article">
<meta property="og:title" content="java讲义">
<meta property="og:url" content="https://weilongqiu.github.io/2017/01/28/java讲义/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="第3章 数据类型和运算符java是一门强类型的语言，所有的变量必须先声明、后使用，从而保证程序更加健壮，可以在编译过程中发现源代码的错误。
3.2 标识符和关键字第4章 流程控制与数组4.5 数组类型4.5.1 理解数组：数组也是一种类型所有的数组具有相同的数据类型。
int[]也是一种数据类型，它本身是一种引用类型，可以使用该类型定义变量，也可以使用该类型进行类型转换。创建int[]类型的对象也">
<meta property="og:updated_time" content="2017-01-28T14:19:27.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java讲义">
<meta name="twitter:description" content="第3章 数据类型和运算符java是一门强类型的语言，所有的变量必须先声明、后使用，从而保证程序更加健壮，可以在编译过程中发现源代码的错误。
3.2 标识符和关键字第4章 流程控制与数组4.5 数组类型4.5.1 理解数组：数组也是一种类型所有的数组具有相同的数据类型。
int[]也是一种数据类型，它本身是一种引用类型，可以使用该类型定义变量，也可以使用该类型进行类型转换。创建int[]类型的对象也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weilongqiu.github.io/2017/01/28/java讲义/"/>





  <title> java讲义 | 我的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">我的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">每天都进步</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://weilongqiu.github.io/2017/01/28/java讲义/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="William Qiu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="我的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="我的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                java讲义
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-28T22:18:55+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第3章-数据类型和运算符"><a href="#第3章-数据类型和运算符" class="headerlink" title="第3章 数据类型和运算符"></a>第3章 数据类型和运算符</h1><p>java是一门强类型的语言，所有的变量必须先声明、后使用，从而保证程序更加健壮，可以在编译过程中发现源代码的错误。</p>
<h2 id="3-2-标识符和关键字"><a href="#3-2-标识符和关键字" class="headerlink" title="3.2 标识符和关键字"></a>3.2 标识符和关键字</h2><h1 id="第4章-流程控制与数组"><a href="#第4章-流程控制与数组" class="headerlink" title="第4章 流程控制与数组"></a>第4章 流程控制与数组</h1><h1 id="4-5-数组类型"><a href="#4-5-数组类型" class="headerlink" title="4.5 数组类型"></a>4.5 数组类型</h1><h3 id="4-5-1-理解数组：数组也是一种类型"><a href="#4-5-1-理解数组：数组也是一种类型" class="headerlink" title="4.5.1 理解数组：数组也是一种类型"></a>4.5.1 理解数组：数组也是一种类型</h3><p>所有的数组具有相同的数据类型。</p>
<p>int[]也是一种数据类型，它本身是一种引用类型，可以使用该类型定义变量，也可以使用该类型进行类型转换。创建int[]类型的对象也就是创建数组，需要使用创建数组的语法。</p>
<h3 id="4-5-2-定义数组"><a href="#4-5-2-定义数组" class="headerlink" title="4.5.2 定义数组"></a>4.5.2 定义数组</h3><p>type[] arrayName[]</p>
<p>定义数组时不能指定数组的长度。</p>
<h3 id="4-5-3-数组的初始化"><a href="#4-5-3-数组的初始化" class="headerlink" title="4.5.3 数组的初始化"></a>4.5.3 数组的初始化</h3><p>数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个元素赋初值。</p>
<p>数组的初始化有两种方式:</p>
<ul>
<li>静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。</li>
<li>动态初始化：初始化时由程序员只指定数组长度，由系统为数组元素分配初始值。</li>
</ul>
<ol>
<li>静态初始化</li>
</ol>
<p>arrayName = new type[]{element1, element2, element3, element4 …}</p>
<p>type[] arrayName = {element1, element2, element3, element4 …}<br>这种语法格式中，直接使用花括号来定义一个数组，花括号把所有的数组元素括起来形成一个数组。</p>
<ol>
<li>动态初始化</li>
</ol>
<p>动态初始化只指定数组的长度，由系统为每个元素指定初始值。</p>
<p>arrayName = new type[length]</p>
<p>注意：不要同时使用静态初始化和动态初始化。</p>
<h3 id="4-5-4-使用数组"><a href="#4-5-4-使用数组" class="headerlink" title="4.5.4 使用数组"></a>4.5.4 使用数组</h3><p>访问数组元素，赋值和取出数组元素的值。</p>
<h3 id="4-5-5-foreach循环"><a href="#4-5-5-foreach循环" class="headerlink" title="4.5.5 foreach循环"></a>4.5.5 foreach循环</h3><p>使用foreach循环遍历数组和集合元素时，无须获取数组和集合长度，无须根据索引数组和集合元素，foreach循环自动遍历数组和集合的每个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(type variableName: array | collection)</div><div class="line">&#123;</div><div class="line">    //variableName 自动迭代访问每个元素...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-6-深入数组"><a href="#4-6-深入数组" class="headerlink" title="4.6 深入数组"></a>4.6 深入数组</h1><p>数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存中是分开存放的。</p>
<h3 id="4-6-1-内存中的数组"><a href="#4-6-1-内存中的数组" class="headerlink" title="4.6.1 内存中的数组"></a>4.6.1 内存中的数组</h3><p>数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可以通过数组变量来访问数组元素。</p>
<p>引用变量是访问真实对象的根本。如果希望在程序中访问数组对象本身，则只能通过这个数组变量的引用来访问它。</p>
<p>实际的数组对象被存储在堆(heap)内存中，如果引用该数组对象的数组引用变量是一个局部变量，那么它被存储在栈(stack)内存中。<br>数组引用变量是访问堆内存中数组元素的根本方式。</p>
<p>如果堆内存中数组不再有任何引用变量指向自己，则这个数组将成为垃圾，该数组所占的内存将会被系统的垃圾回收机制回收。因此，为了让垃圾回收机制回收一个数组所占的内存空间，可以将该数组变量赋为null，也就切断了数组引用变量和实际数组之间的引用关系，实际上的数组也就成了垃圾。</p>
<p>只要类型相互兼容，就可以让一个数组变量指向另一个实际的数组，这种操作会让人数组的长度可变的错觉。</p>
<p>定义并初始化一个数组后，一个用于存放数组的引用变量，另一个用于存放数组本身。</p>
<h3 id="4-6-2-基本类型数组的初始化"><a href="#4-6-2-基本类型数组的初始化" class="headerlink" title="4.6.2 基本类型数组的初始化"></a>4.6.2 基本类型数组的初始化</h3><p>对于基本类型数组，数组元素的值直接存储在对应的数组元素中，因此，初始化数组时，先为该数组分配内存空间，然后直接将数组元素的值存入对应的数组元素中。</p>
<h3 id="4-6-3-引用类型数组的初始化"><a href="#4-6-3-引用类型数组的初始化" class="headerlink" title="4.6.3 引用类型数组的初始化"></a>4.6.3 引用类型数组的初始化</h3><p>引用类型数组的数组元素是引用，因此情况变得更加复杂。每个数组元素里存储的还是引用，它指向另一块内存，这块内存里存储了有效数据。</p>
<h3 id="4-6-4-没有多维数组"><a href="#4-6-4-没有多维数组" class="headerlink" title="4.6.4 没有多维数组"></a>4.6.4 没有多维数组</h3><p>Java语言里提供了支持多维数组的语法。但是，没有多维数组——如果从数组底层的运行机制上来看。</p>
<p>Java语言里的数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实的数组内存。数组元素的类型也可以是引用，如果数组元素的引用再次指向真实的数组内存。</p>
<p>二维数组是一维数组，其数组元素是一维数组；三维数组也是一维数组，其数组元素是二维数组…从这个角度来看，Java语言没有多维数组。</p>
<h3 id="4-6-5-Java-8-增强的工具类：Arrays"><a href="#4-6-5-Java-8-增强的工具类：Arrays" class="headerlink" title="4.6.5 Java 8 增强的工具类：Arrays"></a>4.6.5 Java 8 增强的工具类：Arrays</h3><p>Java语言提供的Arrays类里包含的一些static修饰的方法可以直接操作数组，这个array类里包含了如下几个static修饰的方法（static修饰的方法可以直接通过类名调用）。</p>
<p>int binarySearch(type[] a, type key)：使用二分法查询key元素在a数组中出现的索引；如果a数组不包含key元素值，则返回负数。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确的结果。</p>
<p>int binarySearch(type[] a, int fromIndex, int toIndex, type key)：这个方法与前一个方法类似，但它只搜索a数组中fomeIndex到toIndex索引的元素。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确结果。</p>
<p>type[] copy(type[] original, int length)：这个方法将会把original数组复制成一个新数组，其中length是新数组的长度。如果length小于original数组的长度，则新数组就是原数组前面length个元素；如果length大于original数组的长度，则新数组前面元素就是原数组的所有元素，后面补充0（数值类型）、false（布尔类型）或者null（引用类型）。</p>
<p>type[] copyOfRange(type[] original, int from, int to)：这个方法与前面的方法类似，但这个方法只复制original数组的from索引到to索引的元素。</p>
<p>boolean equals(type[] a, type[] a2)：如果a数组和a2数组的长度相等，而且a数组和a2数组的元素也一一相同，则该方法返回true。</p>
<p>void fill(type[] a, type val)：该方法会把a数组的所有元素都赋值为val。</p>
<p>void fill(type[] a, int fromIndex, int toIndex, type val)：该方法与前一个方法的作用相同，区别只是该方法仅仅将a数组的fromIndex到toIndex索引的数组元素赋值为val。</p>
<p>void sort(type[] a)：该方法对a数组的数组元素进行排序。</p>
<p>void sort(type[] a, int fromIndex, int toIndex):该方法与前一个方法相似，区别是该方法仅仅对fromIndex到toIndex索引的元素排序。</p>
<p>String toString(type[] a)：该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号(,)和空格隔开。</p>
<p>static void arraycopy(Object src, int srcPos, Object dest, int desPos, int length)：将src数组里的元素赋值给dest数组的元素，其中srcPos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。</p>
<p>Java8增强了Array类的功能，为Array类增加了一些工具方法。</p>
<p>void parallelPrefix(xxx[] array, XxxBinaryOperator op)：该方法使用op参数指定的计算公式计算得到的结果作为新的元素。op计算公式包括left、right两个参数，其中left代表数组中前一个索引处的元素，right代表数组中当前索引处的元素，当计算第一个数组元素时，left的值默认为1。</p>
<p>void parallelPrefix(xxx array[], int fromIndex, toIndex)：该方法与上一个方法类似，区别是该方法仅重新计算fromIndex到toIndex索引的元素。</p>
<p>void setAll(xxx[] array, IntToXxxFunction generator)：该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。</p>
<p>void parallelSetAll(xxx[] array, IntToXxxFunction generator)：该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多CPU并行来提高性能。</p>
<p>void parallelSort(xxx[] a)：该方法与Array类以前就有的sort()方法相似，只是该方法增加了并行能力，可以利用多CPU来提高性能。</p>
<p>void parallelSort(xxx[] array, int fromIndex, int toIndex)：该方法与上一个方法相似，区别是该方法仅从fromIndex到toIndex索引的元素进行排序。</p>
<p>Spliterator.OfXxx spliterator(xxxp[] array)：将该数组的所有元素转换成对应的Spliterator对象。</p>
<p>Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)：该方法与上一个方法相似，区别是该方法仅转换startInclusive到endExclusive索引的元素。</p>
<p>XxxStream stream(xxx[] array)：该方法将数组转换为Stream，Stream是Java8新增的流式编程API。</p>
<p>XxxStream stream(xxx[] array, int startInclusive, int endExclusive)：该方法与上一个方法相似，区别是该方法仅从fromIndex到toIndex索引的元素转换为stream。</p>
<h1 id="第5章-面向对象（上）"><a href="#第5章-面向对象（上）" class="headerlink" title="第5章 面向对象（上）"></a>第5章 面向对象（上）</h1><p>所有使用类定义的变量都是引用变量，它们将会引用到类的对象。</p>
<p>Java支持面向对象的三大特征：封装、继承和多态，Java提供了private、protected和public三个访问控制修饰符来实现良好的封装，提供extends关键字来让子类继承父类，子类继承父类就可以继承到父类的成员变量和方法。</p>
<p>构造器用于对类实例进行初始化操作，构造器支持重载。</p>
<h2 id="5-1-类和对象"><a href="#5-1-类和对象" class="headerlink" title="5.1 类和对象"></a>5.1 类和对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[修饰符] class 类名</div><div class="line">&#123;</div><div class="line">    零到多个构造器定义...</div><div class="line">    零到多个成员变量...</div><div class="line">    零到多个方法...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修饰符可以是public、final、abstract，或者完全省略这三个修饰符。</p>
<p>static修饰的成员不能访问没有static修饰的成员。</p>
<p>构造器是一个类创建对象的根本途径。</p>
<p>定义成员变量</p>
<p>[修饰符] 类型 成员变量名 [=默认值];</p>
<p>对成员变量语法格式的详细说明：</p>
<ul>
<li>修饰符可以省略，也可以是public、protected、private、static final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。</li>
<li>类型可以是Java语言允许的任何数据类型，包括基本类型和引用类型。</li>
<li>成员变量名只要是一个合法的标识符即可。如果从程序可读性来看，成员变量名应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写，单词与单词之间不要使用任何分隔符。</li>
<li>定义成员变量可以指定一个可选的默认值。</li>
</ul>
<p>定义方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符] 方法返回值类型 方法名(形参列表)</div><div class="line">&#123;</div><div class="line">    //由零到多条可执行性语句组成的方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对定义方法语法格式说明：</p>
<ul>
<li>修饰符可以省略，也可以是public、protected、private、static final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。</li>
<li>返回值类型可以是Java语言允许的任何数据类型，包括基本类型和引用类型；如果声明了方法返回值类型，则方法体内必须有一个有效的return语句，该语句返回一个变量或表达式，这个变量的表达式必须与此处声明的类型匹配。除此之外，如果一个方法没有返回值，这必须使用void来声明没有返回值。</li>
<li>方法名的命名规则与成员变量的命名规则基本相同，但由于方法用于描述该类或该类的实例的行为特征或功能实现，因此通常建议方法名以英文动词开头。</li>
<li>形参列表用于定义该方法可以接受的参数，形参列表从零组到多组“类型参数 形参名”组合而成，多个参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开。一旦定义方法时指定了形参列表，则调用该方法时必须传入对应的参数值——谁调用方法，谁负责为形参赋值。</li>
</ul>
<p>static是一个特殊的关键字，它可以用于修饰方法、成员变量等成员。static修饰的成员表明它属于这个类本身，而不属于该类的单个实例，因为通常把static修饰的成员变量和方法也称为类变量、类方法。不使用static修饰的普通方法、成员变量则属于该类的单个实例，而不属于该类。因为通常把不使用static修饰的成员变量和方法也称为实例变量、实例方法。</p>
<p>把static修饰的成员变量和方法称为静态变量和静态方法，把不使用static修饰的成员变量和方法称为非静态变量和非静态方法。静态成员不能直接访问非静态成员。</p>
<p>构造器是一个特殊的方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符] 构造器名(形参列表)</div><div class="line">&#123;</div><div class="line">    //由零条到多条可执行语句组成的构造器执行体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对定义构造器语法格式的详细说明：</p>
<ul>
<li>修饰符可以省略，也可以是public、protected、private其中之一。</li>
<li>构造器必须与类名相同。</li>
<li>形参列表和定义方法形参列表的格式完全相同。</li>
</ul>
<p>构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但Java会把这个所谓的构造器当成方法来处理——它就不再是构造器。</p>
<h3 id="5-1-2-对象的产生和使用"><a href="#5-1-2-对象的产生和使用" class="headerlink" title="5.1.2 对象的产生和使用"></a>5.1.2 对象的产生和使用</h3><p>创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。</p>
<p>Java的对象可以访问对象的实例变量和调用对象的方法。</p>
<p>类.类变量|方法<br>实例.类变量|方法</p>
<p>static修饰的方法和成员变量，既可以通过类来调用，也可以通过实例来调用；没有使用static修饰的普通方法和成员变量，只可通过实例来调用。</p>
<h3 id="5-1-3-对象、引用和指针"><a href="#5-1-3-对象、引用和指针" class="headerlink" title="5.1.3 对象、引用和指针"></a>5.1.3 对象、引用和指针</h3><p>栈内存里的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度来看，引用变量与C语言里的指针很像，它们都是存储一个地址值，通过这个地址来引用到实际的对象。实际上，Java里的引用就是C里的指针，只是Java语言把这个指针封装起来，避免开发者进行繁琐的指针操作。</p>
<p>当一个对象被创建成功以后，这个对象将保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。也就是说，不管是数组还是对象，都只能通过引用来访问它们。</p>
<p>不管是数组还是对象，当程序访问引用变量的成员变量或方法时，实际上是访问该变量所引用的数组、对象的成员变量或方法。</p>
<p>堆里的对象可以有对个引用，即多个引用变量指向同一个对象。</p>
<p>如果内存里的对象没有任何变量指向该对象，那么程序将无法访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。</p>
<p>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可，也就是把这些引用变量赋值为null。</p>
<h3 id="5-1-4-对象的this引用"><a href="#5-1-4-对象的this引用" class="headerlink" title="5.1.4 对象的this引用"></a>5.1.4 对象的this引用</h3><p>Java提供了this关键字，this关键字总是指向调用该方法的对象。根据this出现位置的不同，this作为对象的默认引用有两种情形：构造器中引用该构造器正在初始化的对象，在方法中引用调用该方法的对象。</p>
<p>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p>
<p>this可以代表任何对象，当this出现在某个方法体中，它所代表的对象是不确定的，但它的类型是确定的，它所代表的对象只能是当前类；只有当这个方法被调用时，它所代表的对象才被确定下来；谁在调用这个方法，this就代表谁。</p>
<p>大部分时候，一个方法访问类中定义的其他方法、成员变量时不加this前缀的效果是完全一样的。</p>
<p>对于static修饰的方法而言，则可以使用类来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问 不使用static修饰的普通成员，因此，Java语法规定：静态成员不能直接访问非静态成员。</p>
<p>Java编程时不要使用对象去调用static修饰的成员变量、方法，而是应该使用类去调用static修饰的成员变量、方法。</p>
<p>this引用也可以用于在构造器中作为默认引用，由于构造器是直接使用new关键字来调用， 而不是使用对象来调用，所以this在构造器中代表该构造器正在初始化的对象。</p>
<p>与普通方法类似的是，大部分时候，在构造器中访问其他成员变量和方法时都可以省略this前缀，但如果构造器中有一个与成员变量同名的局部变量，又必须在构造器中访问这个被覆盖的成员变量，则必须使用this前缀。</p>
<p>当this作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当作普通方法的返回值。</p>
<h2 id="5-2-方法详解"><a href="#5-2-方法详解" class="headerlink" title="5.2 方法详解"></a>5.2 方法详解</h2><p>方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。Java里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类，要么属于对象。</p>
<h3 id="5-2-1-方法的所属性"><a href="#5-2-1-方法的所属性" class="headerlink" title="5.2.1 方法的所属性"></a>5.2.1 方法的所属性</h3><p>如果需要定义方法，则只能在类体内定义，不能独立定义一个方法。一旦将一个方法定义在某个类的类体内，如果这个方法使用了static修饰，则这个方法属于这个类，否则这个方法属于这个类的实例。</p>
<p>Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的，永远都不会改变。</p>
<p>Java里的方法不能独立存在，它必须属于一个类或一个对象，因此方法也不能像函数那样被独立执行，执行方法时必须使用类或对象来作为调用者，即所有方法都必须使用”类.方法”或”对象.方法”的形式来调用。同一个类的一个方法调用另外一个方法时，如果被调方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行，但实际上还是使用this或者类来作为调用者。</p>
<p>永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属,Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。</p>
<ul>
<li>方法不能独立定义，方法只能在类体里定义。</li>
<li>从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。</li>
<li>永远不能独立执行方法，执行方法必须使用类或对象作为调用者。</li>
</ul>
<p>使用static修饰的方法属于这个类本身，使用static修饰的方法既可以使用类作为调用者来调用，也可以使用对象作为调用者来调用。使用static修饰的方法还是属于这个类的，因此使用该类的任何对象来调用这个方法时将会得到相同的执行结果，这是由于底层依然是使用这些实例所属的类作为调用者。</p>
<p>没有static修饰的方法则属于该类的对象，不属于这个类本身。因此，没有static修饰的方法只能使用对象作为调用者来调用，不能使用类作为调用者来调用。使用不同的对象来调用同一个普通方法，可能得到不同的结果。</p>
<h3 id="5-2-2方法的参数传递机制"><a href="#5-2-2方法的参数传递机制" class="headerlink" title="5.2.2方法的参数传递机制"></a>5.2.2方法的参数传递机制</h3><p>如果声明方法时包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传给形参的参数值也被称为实参。</p>
<p>Java里方法的参数传递方式只有一种：值传递。将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。</p>
<h3 id="5-2-3-形参个数可变的方法"><a href="#5-2-3-形参个数可变的方法" class="headerlink" title="5.2.3 形参个数可变的方法"></a>5.2.3 形参个数可变的方法</h3><p>Java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的形参。如果在定义方法时，在最后一个形参的类型后增加三个点(…)，则表明该形参可以接受多个参数值，多个参数值将被当作数组传入。</p>
<p>数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后。一个方法最多只能有一个长度可变的形参。</p>
<h3 id="5-2-4-递归方法"><a href="#5-2-4-递归方法" class="headerlink" title="5.2.4 递归方法"></a>5.2.4 递归方法</h3><p>一个方法体内调用它自身，被称为方法递归。方法递归包含了一种隐式的循环，它重复执行某段代码，但这种重复执行无须循环控制。</p>
<p>递归一定要向已知方向递归。</p>
<h3 id="5-2-5-方法重载"><a href="#5-2-5-方法重载" class="headerlink" title="5.2.5 方法重载"></a>5.2.5 方法重载</h3><p>Java允许同一个类里定义多个同名方法，只要形参列表不同就行。如果同一个类中包含了两个或两个以上的方法名相同，但形参列表不同，则被称为方法重载。</p>
<p>Java里面确定一个方法需要三个要素：</p>
<ul>
<li>调用者，也就是方法的所属者，既可以是类，也可以是对象。</li>
<li>方法名，方法的标识。</li>
<li>形参列表，当调用方法时，系统将根据传入的实参列表匹配。</li>
</ul>
<p>方法重载的要求就是两同一不同：同一个类中方法名相同，形参列表不同。至于方法的其他部分，如方法的返回值类型、修饰符等，与方法重载没有任何关系。</p>
<h2 id="5-3-成员变量和局部变量"><a href="#5-3-成员变量和局部变量" class="headerlink" title="5.3 成员变量和局部变量"></a>5.3 成员变量和局部变量</h2><p>Java语言中，根据定义变量位置的不同，可以将变量分为两大类：成员变量和局部变量。成员变量和局部变量的运行机制存在较大的差异。</p>
<h3 id="5-3-1-成员变量和局部变量"><a href="#5-3-1-成员变量和局部变量" class="headerlink" title="5.3.1 成员变量和局部变量"></a>5.3.1 成员变量和局部变量</h3><p>成员变量指的是在类里定义的变量，也就是前面所介绍的field；局部变量指的是在方法里定义的变量。不管是成员变量还是局部变量，都应该遵循相同的命名规则：从语法的角度来看，只要一个合法的标识符即可；但从程序可读性角度来看，应该是多个有意义的单词连缀而成，其中第一个单词首字母小写，后没每个单词首字母大写。</p>
<p>成员变量被分为类变量和实例变量两种，定义成员变量时没有static修饰的就是实例变量，有static修饰的就是类变量。其中类变量从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同；而实例变量则从该类的实例被创建开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。</p>
<p>一个类在使用之前需要经过类加载、类验证、类准备、类解析、类初始化等几个阶段。</p>
<p>可以把类变量和实例变量统称为成员变量，其中类变量可以理解为类成员变量，它可以作为类本身的一个成员，与类本身共存亡；实例变量则可理解为实例成员变量，它作为实例的一个成员，与实例共存亡。</p>
<p>只要类存在，程序就可以访问该类的类变量。</p>
<p>类.类变量</p>
<p>只要实例存在，程序就可以访问该实例的实例变量。</p>
<p>实例.实例变量</p>
<p>当然，类变量可以让该类的实例来访问。</p>
<p>实例.类变量</p>
<p>但由于这个实例并不拥有这个类变量，因此它访问的并不是这个实例的变量，依然是访问它对应类的变量。如果通过一个实例修改了类变量，由于这个类变量并不属于它，而是属于它对应的类。因此，修改的依然是类的类变量，与通过该类来修改类变量的结果完全相同，这会导致该类的其他成员实例来访问这个类变量时也将获得这个被修改过的值。</p>
<p>成员变量无须显示初始化，只要为一个类定义了类变量或实例变量，系统就会在这类的准备阶段或创建该类的实例时进行默认初始化，成员变量默认初始化的赋值规则与动态数组初始化时数组元素的赋值规则完全相同。</p>
<p>类变量的作用域比实例变量的作用域更大：实例变量随实例的存在而存在，而类变量则随变量的存在而存在。实例也可以访问类变量，同一个类的所有实例访问类变量时，实际上访问的是该类本身的同一个变量，也就是说，访问了同一片内存区。</p>
<p>局部变量根据定义的形式不同，又可以被分为如下三种：</p>
<ul>
<li>形参，在定义方法签名时定义的变量，形参的作用域在整个方法内有效。</li>
<li>方法局部变量，在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效。</li>
<li>代码块局部变量，在代码块中定义的局部变量，这个变量的作用域从定义该变量的地方生效，到该代码块j结束时失效。</li>
</ul>
<p>与成员变量不同的是，局部变量除了形参之外，都必须显示初始化。也就是说，必须先给方法局部变量和代码块局部变量指定初始值，否则不可以访问它们。</p>
<p>只要离开了代码块局部变量所在的代码块，这个局部变量就立刻被销毁，变为不可见。</p>
<p>对于方法局部变量，其作用域从定义该变量开始，直到该方法结束。</p>
<p>形参的作用域是整个方法体内有效，而且形参也无须显式初始化，形参的初始化在调用该方法时由系统自动完成，形参的初始化由方法的调用者负责指定。</p>
<p>当通过类或对象调用某个方法时，系统会在该方法栈区为所有的形参分配内存空间，并将实参的值赋给对应的形参，这就完成了形参的初始化。</p>
<p>在同一个类里，成员变量的作用域范围是整个类有效，一个类里不能定义两个同名的成员变量，即使一个是类变量，一个是实例变量也不行；一个方法里不能定义两个同名的方法局部变量，方法局部变量与形参也不能同名；同一个方法中不同代码块内的代码块局部变量可以同名；如果先定义代码块局部变量，后定义方法局部变量，前面定义的代码块局部变量与后面定义的代码块局部变量也可以同名。</p>
<p>Java允许局部变量和成员变量同名，如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可以使用this（对于实例变量）或类名（对于类变量）作为调用者来限定访问成员变量。</p>
<h3 id="5-3-2-成员变量的初始化和内存中的运行机制"><a href="#5-3-2-成员变量的初始化和内存中的运行机制" class="headerlink" title="5.3.2 成员变量的初始化和内存中的运行机制"></a>5.3.2 成员变量的初始化和内存中的运行机制</h3><p>当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值。</p>
<h3 id="5-3-3-局部变量的初始化和内存中的运行机制"><a href="#5-3-3-局部变量的初始化和内存中的运行机制" class="headerlink" title="5.3.3 局部变量的初始化和内存中的运行机制"></a>5.3.3 局部变量的初始化和内存中的运行机制</h3><p>局部变量定义后，必须经过显示初始化后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。</p>
<p>与成员变量不同，局部变量不属于任何类或实例，因此它总是保存在其所在方法的栈内存中。如果局部变量是几本类型的变量，则直接把这个变量的值保存在该变量对应的内存中；如果局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对象或数组。</p>
<p>栈内存中的变量无须系统垃圾回收，往往随方法或代码块运行结束而结束。因此，局部变量的作用域是从初始化该变量开始，直到该方法或该代码块运行完成而结束。因为局部变量只保存基本类型的值或对象的引用，因此局部变量所占的内存区通常比较小。</p>
<h3 id="5-3-4-变量的使用规则"><a href="#5-3-4-变量的使用规则" class="headerlink" title="5.3.4 变量的使用规则"></a>5.3.4 变量的使用规则</h3><p>对于一个循环变量而言，只需要它在循环体内有效，因此只需要把这个变量放在循环体内（也就是代码块内定义），从而保证这个变量的作用域仅在该代码块内。</p>
<p>如果有如下几种情形，则应该考虑使用成员变量：</p>
<ul>
<li>如果需要定义的变量是用于描述某个类或某个对象的固有信息的，例如人的身高、体重等信息，它们是人对象的固有信息，每个人对象都具有这些信息。这种变量应该定义为成员变量。如果这种信息对这个类的所有实例完全相同，或者说它是类相关的，这种类想相关的信息应该定义成类变量；如果这种信息是实例相关的，应该定义成实例变量。</li>
<li>如果在某个类中需要以一个变量来保存该类或者实例运行时的状态信息，这种用于保存某个类或某个实例状态信息的变量通过应该使用成员变量。</li>
<li>如果某个信息需要在某个类的多个方法之间进行共享，则这个信息应该使用成员变量来保存。</li>
</ul>
<p>即使在程序中使用局部变量，也应该尽可能地缩小局部变量的作用范围，局部变量的作用范围越小，它在内存停留的时间就越短，程序运行性能就越好。</p>
<h2 id="5-4-隐藏和封装"><a href="#5-4-隐藏和封装" class="headerlink" title="5.4 隐藏和封装"></a>5.4 隐藏和封装</h2><h3 id="5-4-1-理解封装"><a href="#5-4-1-理解封装" class="headerlink" title="5.4.1 理解封装"></a>5.4.1 理解封装</h3><p>封装(Encapsulation)是面向对象的三大特征之一（另外两个是继承和多态），它指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。</p>
<p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节。</li>
<li>让使用者只通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问。</li>
<li>可进行数据检查，从而有利于保证对象信息的完整性。</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
<p>为了实现良好的封装，需要从两个方面考虑。</p>
<ul>
<li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问。</li>
<li>把方法暴露出来，让方法来控制对这些成员变量进行安全访问和操作。</li>
</ul>
<p>把该隐藏的隐藏起来，把该暴露的暴露出来。</p>
<h3 id="5-4-2-访问控制符"><a href="#5-4-2-访问控制符" class="headerlink" title="5.4.2 访问控制符"></a>5.4.2 访问控制符</h3><p>private、protected和public，分别代表了3个访问控制级别，另外还加一个不加任何访问控制符的访问控制级别。</p>
<ul>
<li>private（当前类访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在当前类的内部被访问。这个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部。</li>
<li>default（包含访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类不使用任何访问控制符修饰，就称它是包访问权限的，default访问控制的成员或外部类可以被相同包下的其他类访问。</li>
<li>protected（子类访问权限）：如果一个成员（包含 成员变量、方法和构造器等）使用protected访问控制修饰符，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用protected来修饰一个方法，通常是希望其子类来重写这个方法。</li>
<li>public（公共访问权限）：这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方法和构造器等）或者一个外部类使用public访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子关系。</li>
</ul>
<p>访问控制符用于控制一个类的成员是否可以被其他类访问，对于局部变量而言，其作用域就是它所在的方法，不可能被其他类访问，因此不能使用访问控制符来修饰。</p>
<p>对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别：public和默认，外部类不能使用private和protected修饰，因为外部类没有处于任何类的内部，也就没有其他所在类的内部、所在类的子类两个范围，因此，private和protected访问控制符对外部类没有意义。</p>
<p>外部类可以使用pulic和包访问权限，使用public修饰的外部类可以被所有类使用，如声明变量、创建实例；不使用任何访问控制符修饰的外部类只能被同一包中的其他类访问。</p>
<p>如果一个Java源文件里定义的所有类都没有使用public修饰，则这个Java源文件的文件名可以是一切合法的文件名；但如果一个Java源文件里定义了一个public修饰的类，则这个源文件的文件名必须与 public修饰的类的类名相同。</p>
<p>一个类常常就是一个小的模块，应该只让这个模块公开必须让外界知道的内容，而隐藏其他一切内容。进行程序设计时，应该尽量避免一个模块直接操作和访问另一个模块的数据，模块设计追求高内聚（尽可能把模块的内部数据、功能实现细节隐藏在模块内部独立完成，不允许外部直接干预）、低耦合（仅暴露少量的方法给外部使用）。</p>
<p>关于访问控制符的使用，存在如下几条基本原则。</p>
<ul>
<li>类的绝大部分成员变量都应该使用private修饰，只有一些static修饰的、类似全局变量的成员变量，才可能考虑使用public修饰。除此之外，有些方法只用于辅助实现该类的其他方法，这些方法被称为工具方法，工具方法也应该使用private修饰。</li>
<li>如果某个类主要用做其他类的父类，该类里包含的大部分方法可能仅希望被子类重写，而不想被外界直接调用，则应该使用protected修饰这些方法。</li>
<li>希望暴露出来给其他类自由调用的方法应该使用public修饰。因此，类的构造器通过使用public修饰，从而允许其他地方创建该类的实例。因为外部类通常希望被其他类自由使用，所以大部分外部类都使用public修饰。</li>
</ul>
<h3 id="5-4-3-package、import和import-static"><a href="#5-4-3-package、import和import-static" class="headerlink" title="5.4.3 package、import和import static"></a>5.4.3 package、import和import static</h3><p>Java引入包（Package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。</p>
<p>Java允许将一组功能相关的类放在同一个package下，从而组成逻辑上的类库单元。如果希望把一个类放在指定的包结构下，应该在Java源程序的第一个非注释行放置如下格式的代码：<br>package packageName;</p>
<p>一旦一个Java源文件中使用了package语句，就意味着该源文件里定义的所有类都属于这个包。位于包中的每个类的完整类名都应该是包名和类名的组合，如果其他人需要使用该包下的类，也应该使用包名加类名的组合。</p>
<p>位于包中的类，在文件系统中也必须有与包名层次相同的目录结构。</p>
<p>同一个包中的类不必位于相同的目录下。</p>
<p>应该把Java源文件放在与包名一致的目录结构下。</p>
<p>通常建议将源文件和class文件分开存放，以便管理。</p>
<p>不是有了目录结构，就等于有了包名。为Java类添加包必须在Java源文件中通过package语句指定，单靠目录名是没法指定的。Java的包机制需要两个方面保证：源文件里使用package语句指定包名；class文件必须放在对应的路径下。</p>
<p>Java语法只要求包名是有效的标识符即可，但从可读性规范角度来看，包名应该全部是小写字母，而且应该由一个或多个有意义的单词连缀而成。</p>
<p>package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，即只能包含一条package语句，该源文件中可以定义多个类，则这些类将全部位于该包下。</p>
<p>如果没有显示指定package语句，则处于默认包下。</p>
<p>同一个包下的类可以自由访问。</p>
<p>父包和子包之间确实表示了某种内在的逻辑关系，确实可以表明后者是前者的一个模块。但父包和子包在用法上不存在任何关系，如果父包中的类需要使用子包中的类，则必须使用子包的全名，而不能省略父包部分。</p>
<p>如果创建处于其他包下类的实例，则在调用构造器时也需要使用包前缀。</p>
<p>如果需要使用不同包中的其他类时，总是需要使用该类的全名，这是一件很繁琐的事情。</p>
<p>为了简化编程，Java引入了import关键字，import可以向某个Java文件中导入指定包层次下某个类或全部类，import语句应该出现在package语句（如果有的话）之后、类定义之前。一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个imprt语句用于导入多个包层次下的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import package.subpackage...*;</div></pre></td></tr></table></figure>
<p>上面import语句中的星号（*）只能代表类，不能代表包。</p>
<p>一旦在Java源文件中使用import语句来导入指定类，在该源文件中使用这些类时就可以省略包前缀，不再使用类全名。</p>
<p>Java默认为所有源文件导入java.lang包下的所有类，因此前面在Java程序中使用String、System类时都无须使用import语句来导入这些类。但对于前面介绍数组时提到的Array类，其位于java.util包下，则必须使用import语句来导入该类。</p>
<p>静态导入语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。</p>
<p>静态导入使用import static语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法。</p>
<p>导入指定类的单个静态成员变量、方法的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static package.subpackage...ClassName.fieldName|methodName;</div></pre></td></tr></table></figure>
<p>上面语法导入package.subpackage…ClassName类名中名为filedName的静态成员变量或者类名为methodName的静态方法。</p>
<p>导入指定类的全部静态成员变量、方法的语法格式入下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static package.subpackage...ClassName.*;</div></pre></td></tr></table></figure>
<p>上述语法中的星号只能代表静态成员变量或方法名。</p>
<p>import static语句也放在Java源文件的package语句（如果有的话）之后、类定义之前，即放在与普通import语句想相同的位置，而且import语句和import static语句之间没有任何顺序要求。</p>
<p>使用import可以省略写包名，而使用import static则可以连类名都省略。</p>
<p>Java源文件的大体结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package 语句                   //0个或1个，必须放在文件开始</div><div class="line">import | import static        //0个或多个，必须放在所有类定义之前</div><div class="line">public classDefinition | interfaceDefinition | enumDefinition</div><div class="line">                                //0个或1个public类、接口或枚举定义</div><div class="line"></div><div class="line">classDefinition | interfaceDefinition | enumDefinition</div><div class="line">                                //0个或多个普通类、接口或枚举定义</div></pre></td></tr></table></figure>
<h3 id="5-4-4-Java的常用包"><a href="#5-4-4-Java的常用包" class="headerlink" title="5.4.4 Java的常用包"></a>5.4.4 Java的常用包</h3><p>Java的核心类都放在java包以及其子包下，Java扩展的许多类都放在javax包以及其子包下。这些实用类也就是前面说的API（应用程序接口），Oracle按这些类的功能分别放在不同的包下。</p>
<ul>
<li>java.lang：这个包下包含了Java语言的核心类，如String、Math、System和Thread类等，使用这个包下的类无须使用import语句导入，系统会自动导入这个包下的所有类。</li>
<li>java.util：这个包下包含了Java的大量工具类/接口和集合框架类/接口，例如Array和List、Set等。</li>
<li>java.net：这个包下包含了一些Java网络编程相关的类/接口。</li>
<li>java.io：这个包下包含了一些Java输入/输出编程相关的类/接口。</li>
<li>java.text：这个包下包含了一些Java格式化相关的类。</li>
<li>java.sql：这个包下包含了Java进行JDBC数据库编程的相关类/接口。</li>
<li>java.awt：这个包下包含了抽象窗口工具集（Abstract Window Toolkits）的相关类/接口，这些类主要用于构建图形用户界面（GUI）程序。</li>
<li>java.swing：这个包下包含了Swing图形用户界面编程的相关类/接口，这些类可用于构建平台五官的GUI程序。</li>
</ul>
<h2 id="5-5-深入构造器"><a href="#5-5-深入构造器" class="headerlink" title="5.5 深入构造器"></a>5.5 深入构造器</h2><p>构造器是一个特殊的方法，这个特殊方法用于创建实例时执行初始化。构造器是创建对象的重要途径（即使使用工厂模式、反射等方式创建对象，其实质依然是依赖于构造器），因此，Java类必须包含一个或一个以上的构造器。</p>
<h3 id="5-5-1-使用构造器执行初始化"><a href="#5-5-1-使用构造器执行初始化" class="headerlink" title="5.5.1 使用构造器执行初始化"></a>5.5.1 使用构造器执行初始化</h3><p>构造器最大的用处就是在创建对象时执行初始化。当创建一个对象时，系统为这个对象的实例变量进行默认初始化，这种默认初始化把所有基本类型变量设为0（对数值类型实例变量）或false（对布尔类型实例变量），把所有引用类型的实例变量设置为null。</p>
<p>如果想改变这种默认的初始化，想让系统创建对象时就为该对象的实例变量显示指定初始值，就可以通过构造器来实现。</p>
<p>如果程序员没有为Java类提供任何构造器，则系统会为这个类提供一个无参数的构造器，这个构造器的执行体为空，不做任何事情，无论如何，Java类至少包含一个构造器。</p>
<p>构造器是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。实际上，当程序调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生——这些操作在构造器执行之前就完成了。也就是说，当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。当构造器的执行体 执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。</p>
<p>一旦程序员提供了自定义的构造器，系统就不再提供默认的构造器。</p>
<p>如果用户希望该类保留无参数的构造器，或者希望有多个初始化过程，则可以为该类提供多个构造器。如果一个类里提供了多个构造器，就形成了构造器的重载。</p>
<p>因为构造器主要用于被其他方法调用，用以返回该类的实例，因而通常把构造器设置成public访问权限，从而允许系统中的任何位置的类来创建该类的对象。除非在一些极端的情况下，业务需要限制创建该类的对象，可以把构造器设置成其他访问权限，例如设置为protected，主要用于被其子类调用；把其设置为private，阻止其他类创建该类的实例。</p>
<h3 id="5-5-2-构造器重载"><a href="#5-5-2-构造器重载" class="headerlink" title="5.5.2 构造器重载"></a>5.5.2 构造器重载</h3><p>同一个类具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。构造器重载允许Java类里包含多个初始化逻辑，从而允许使用不同的构造器来初始化Java对象。</p>
<p>构造器重载和方法重载基本相似：要求构造器的名字相同，这一点无须特别要求，因为构造器必须与类名相同，所以同一个类的所有构造器名肯定相同。为了让系统区分不同的构造器，多个构造器的参数列表必须不同。</p>
<p>如果系统包含了多个构造器，其中一个构造器的执行体里完全包含另一个构造器的执行体，为了在构造器B中调用构造器A中的初始化代码，又不会重新创建一个Java对象，可以使用this关键字来调用相应的构造器。</p>
<p>使用this调用另一个重载的构造器只能在构造器中使用，而且必须作为构造器执行体的第一条语句。使用this调用重载的构造器时，系统会根据this后括号里的实参来调用形参列表与之对应的构造器。</p>
<h2 id="5-6-类的继承"><a href="#5-6-类的继承" class="headerlink" title="5.6 类的继承"></a>5.6 类的继承</h2><p>继承是面向对象的三大特征之一，也是实现软件复用的重要手段。Java的继承具有单继承的特点，每个子类只有一个直接父类。</p>
<h3 id="5-6-1-继承的特点"><a href="#5-6-1-继承的特点" class="headerlink" title="5.6.1 继承的特点"></a>5.6.1 继承的特点</h3><p>Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类称为父类，有的也称为基类、超类。父类和子类的关系，是一种一般和特殊的关系。</p>
<p>因为子类是一种特殊的父类，因此父类包含的范围总比子类包含的范围要大，所以可以认为父类是大类，而子类是小类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">修饰符 class SubClass extends SuperClass</div><div class="line">&#123;</div><div class="line">    //类定义部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类是对父类的扩展，子类是一种特殊的父类。子类扩展了父类，将可以获得父类的全部成员变量和方法。值得指出的是，Java的子类不能获得父类的构造器。</p>
<p>Java语言摒弃了C++中难以理解的多继承操作，即每个类最多只有一个直接父类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class SubClass extends Base1, Base2, Base3&#123;...&#125;</div></pre></td></tr></table></figure>
<p>Java类只能有一个直接父类，实际上，Java类可以有无限多个间接父类。</p>
<p>如果定义一个Java类时并未显示指定这个类的直接父类，则这个类默认扩展java.lang.Object类。因此，java.lang.Object类是所有类的父类，要么是其直接父类，要么是其间接父类。因此所有的Java对象都可调用java.lang.Object类所定义的实例方法。</p>
<p>从子类角度来看，子类扩展（extends）了父类；但从父类的角度来看，父类派生（derive）出了子类。</p>
<h3 id="5-6-2-重写父类的方法"><a href="#5-6-2-重写父类的方法" class="headerlink" title="5.6.2 重写父类的方法"></a>5.6.2 重写父类的方法</h3><p>子类扩展了父类，子类是一个特殊的父类。大部分时候，子类总是以父类为基础，额外增加新的成员变量和方法。但有一种情况例外：子类需要重新写父类的方法。</p>
<p>子类包含与父类同名方法的现象被称为方法重写（Override），也被称为方法覆盖。可以说子类重写了父类的方法，也可以说子类覆盖了父类的方法。</p>
<p>方法的重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。尤其要指出的是，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法。</p>
<p>如果父类方法具有private访问权限，则该方法对其子类是隐藏的，因此其子类无法访问该方法，也就是无法重写该方法。</p>
<p>重载 overload<br>重写 override</p>
<h3 id="5-6-3-super限定"><a href="#5-6-3-super限定" class="headerlink" title="5.6.3 super限定"></a>5.6.3 super限定</h3><p>如果需要在子类方法中调用父类被覆盖的实例方法，则可使用super限定来调用父类被覆盖的实例方法。</p>
<p>super是Java提供的一个关键字，super用于限定该对象调用它从父类继承得到的实例变量或方法。正如this不能出现在static修饰的方法中一样，super也不能出现在static修饰的方法中。static修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象，因而super限定也就失去了意义。</p>
<p>如果在构造器中使用super，则super用于限定该构造器初始化是从该父类继承得到的实例变量，而不是该类自己定义的实例变量。</p>
<p>如果子类定义了和父类同名的实例变量，则会发生子类实例变量隐藏父类实例变量的情形。在正常情况下，子类里定义的方法直接访问该实例变量默认会访问到子类中定义的实例变量，无法访问到父类中被隐藏的实例变量。在子类定义的实例方法中可以通过super来访问父类中被隐藏的实例变量。</p>
<p>如果子类里没有包含和父类同名的成员变量，那么在子类实例方法中访问该成员变量时，则无须显示使用super或父类名作为调用者。如果在某个方法中访问名为a的成员变量，但没有显示指定调用者，则系统查找a的顺序为：</p>
<ol>
<li>查找该方法中是否有名为a的局部变量。</li>
<li>查找当前类中是否包含名为a的成员变量。</li>
<li>查找a的直接父类中是否包含名为a的成员变量，依次上溯a的所有父类，直到java.lang.Object类，如果最终不能找到名为a的成员变量，则系统出现编译错误。</li>
</ol>
<p>如果被覆盖的是类变量，在子类的方法中则可以通过父类名作为调用者来访问被覆盖的类变量。</p>
<p>当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。</p>
<p>如果在子类里定义了与父类中已有变量同名个的变量，那么子类中定义的变量会隐藏父类中定义的变量。注意不是完全覆盖，因此系统在创建子类对象时，依然会为父类中定义的、被隐藏的变量分配内存空间。</p>
<p>为了在子类方法中访问父类中定义的、被隐藏的实例变量，或为了在子类方法中调用父类中定义的、被覆盖（Override）的方法，可以通过super.作为限定来调用这些实例变量和实例方法。</p>
<h3 id="5-6-4-调用父类构造器"><a href="#5-6-4-调用父类构造器" class="headerlink" title="5.6.4 调用父类构造器"></a>5.6.4 调用父类构造器</h3><p>子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码，类似于一个构造器调用另一个重载的构造器。</p>
<p>在一个构造器中调用另一个重载的构造器使用this调用来完成，在子类构造器中调用父类构造器使用super调用来完成。</p>
<p>使用super调用父类构造器必须出现在子类构造器执行体的第一行，所以this调用和super调用不会同时出现。</p>
<p>不管是否使用super调用来执行父类构造器的初始化代码，子类构造器总会调用父类构造器一次。子类构造器调用父类构造器分如下几种情况：</p>
<ul>
<li>子类构造器执行体的第一行使用super显示调用父类构造器，系统将根据super调用里传入的实参列表调用父类对应的构造器。</li>
<li>子类构造器执行体的第一行代码使用this显示调用本类中重载的构造器，系统将根据this调用里传入的实参列表调用本类中的另一个构造器。执行本类另一个构造器时即会调用父类的构造器。</li>
<li>子类构造器执行体中既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。</li>
</ul>
<p>不管上面哪种情况，当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行；不仅如此，执行父类构造器时，系统会再次上溯执行其父类构造器……以此类推，创建任何Java对象，最先执行的总是java.lang.Object类的构造器。</p>
<p>创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果某个类通过this调用了同类中重载的构造器，就会依次执行此父类的多个构造器。</p>
<h2 id="5-7-多态"><a href="#5-7-多态" class="headerlink" title="5.7 多态"></a>5.7 多态</h2><p>Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现多态（Polymorphism）。</p>
<h3 id="5-7-1-多态性"><a href="#5-7-1-多态性" class="headerlink" title="5.7.1 多态性"></a>5.7.1 多态性</h3><p>子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型（upcasting），向上转型有系统自动完成。</p>
<p>当把一个子类对象直接赋给父类引用变量时，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
<p>与方法不同的是，对象的实例变量则不具备多态性。</p>
<p>引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法。</p>
<p>通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时所定义的成员变量。</p>
<h3 id="5-7-2引用变量的强制类型转换"><a href="#5-7-2引用变量的强制类型转换" class="headerlink" title="5.7.2引用变量的强制类型转换"></a>5.7.2引用变量的强制类型转换</h3><p>编写Java程序时，引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使它实际所引用的对象确实包含该方法。如果需要让这个引用变量调用它运行时类型的方法，则必须把它强制类型转换成运行时类型，强制类型转化需要借助于类型转换运算符。</p>
<p>类型转换运算符是小括号，类型转换运算符的用法是：(type) varialbe，这种用法可以将variable变量转换成一个type类型的变量。</p>
<p>除此之外，这个类型转换运算符还可以将一个引用类型变量转换成其子类类型。这种强制类型转换不是万能的，当进行强制类型转换时需要注意：</p>
<ul>
<li>基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括整数型、字符型和浮点型。但数值类型和布尔类型之间不能进行类型转换。</li>
<li>引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行（即编译时类型为父类类型，而运行时类型是子类类型），否则将在运行时引发ClassCastException异常。</li>
</ul>
<h3 id="instatof运算符"><a href="#instatof运算符" class="headerlink" title="instatof运算符"></a>instatof运算符</h3><p>instanceof运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是接口，可以把接口理解成一种特殊的类），它用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。如果是，则返回true，否则返回false。</p>
<p>在使用instanceof运算符时需要注意：instanceof运算符前面操作数的编译时类型要么与后面的类型相同，要么与后面的类具有父子继承关系，否则会引起编译错误。</p>
<p>instanceof运算符的作用是：在进行强制类型转换之前，首先判断前一个对象是否是后一个类的实例，是否可以转换成功，从而保证代码更加健壮。</p>
<p>instanceof和(type)是Java提供的两个相关的运算符，通常先用instanceof判断一个对象是否可以强制类型转换，然后再使用（type）运算符进行强制类型转换，从而保证程序不会出现错误。</p>
<h2 id="5-8-继承与组合"><a href="#5-8-继承与组合" class="headerlink" title="5.8 继承与组合"></a>5.8 继承与组合</h2><p>继承是实现类复用的重要手段，但继承带来了一个最大的坏处：破坏封装。相比之下，组合也是实现类复用的重要方式，而采用组合方式来实现类复用则能提供更好的封装性。</p>
<p>5.8.1 使用继承的注意点</p>
<p>子类扩展父类时，子类可以从父类继承得到成员变量和方法，如果访问权限允许，子类可以直接访问父类的成员变量和方法，相当于子类可以直接复用父类的成员变量和方法，确实非常方便。</p>
<p>继承带来了高度复用的同时，也带来了一个严重的问题：继承严重破坏了父类的封装性。</p>
<p>为了保证父类有良好的封装性，不会被子类随意改变，设计父类应该遵循如下规则：</p>
<ul>
<li>尽量隐藏父类的内部数据。尽量把父类的所有成员变量都设置为private访问类型，不要让子类直接访问父类的成员变量。</li>
<li>不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，让子类无法访问该方法；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用final修饰符来修饰该方法；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected来修饰该方法。</li>
<li>尽量不要在父类构造器中调用将要被子类重写的方法。</li>
</ul>
<p>如果想把某些类设置成最终类，即不能被当成父类，则可以使用final修饰这个类。</p>
<h3 id="5-8-2-利用组合实现复用"><a href="#5-8-2-利用组合实现复用" class="headerlink" title="5.8.2 利用组合实现复用"></a>5.8.2 利用组合实现复用</h3><p>如果需要复用一个类，除了可以把这个类当成基类来继承之外，还可以把该类当成另一个类的组合成分，从而允许新类直接复用该类的public方法。不管是继承还是组合，都允许在新类（对于继承就是子类）中直接复用旧类的方法。</p>
<p>对于继承而言，子类可以直接获得父类的public方法，程序员使用子类时，将可以直接访问该子类从父类那里继承到的方法；而组合则是把旧类对象作为新类的成员变量组合起来，用以实现新类的功能，用户看到的是新类的方法，而不能看到被组合对象的方法。因此，通常需要在新类里使用private修饰被组合的旧类对象。</p>
<p>仅从类复用的角度来看，不难发现父类的功能等同于被组合的类，都将自身的方法提供给新类使用；子类和组合关系里的整体类，都可复用原有类的方法，用于实现自身的功能。</p>
<p>大部分时候，继承关系中从多个子类里抽象出共有父类的过程，类似于组合关系中从多个整体类里提取被组合的过程；继承关系中从父类派生子类的过程，则类似于组合关系中把被组合类组合到整体类的过程。</p>
<p>继承是对已有的类做一番改造，以此获得一个特殊的版本。简而言之，就是将一个较为抽象的类改造成适用于某些特定需求的类。如果两个类之间有明确的整体、部分关系，此时就应该采用组合关系来实现复用。</p>
<p>总之，继承要表达的是一种“是(is-a)”的关系，而组合表达的是“有(has-a)”的关系。</p>
<h2 id="5-9-初始化块"><a href="#5-9-初始化块" class="headerlink" title="5.9 初始化块"></a>5.9 初始化块</h2><p>Java使用构造器来对单个对象进行初始化操作，使用构造器先完成整个Java对象的状态初始化，然后将Java对象返回给程序，从而让该Java对象的信息更加完整。与构造器类似的是初始化块，它也可以对Java对象进行初始化操作。</p>
<h3 id="5-9-1-使用初始化块"><a href="#5-9-1-使用初始化块" class="headerlink" title="5.9.1 使用初始化块"></a>5.9.1 使用初始化块</h3><p>初始化块是Java类里可出现的第4种成员（前面依次有成员变量、方法和构造器），一个类里可以有多个初始化块，相同类型的初始化块之间有顺序；前面定义的初始化块先运行，后面定义的初始化块后在执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[修饰符]</div><div class="line">&#123;</div><div class="line">    //初始化块的可执行代码</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化块的修饰符只能是static，使用static修饰的初始化块被称为静态初始化块。初始化块里的代码可以包含任何可执行的语句，包括定义局部变量、调用其他对象的方法，以及使用分支、循环语句等。</p>
<p>当创建Java对象时，系统总是先调用该类里定义的初始化块，如果一个类里定义了2个普通的初始化块，则前面定义的初始化块先执行，后面定义的初始化块后执行。</p>
<p>初始化块虽然也是Java类的一种成员，但它没有名字，也就是没有标识，因此无法通过类、对象来调用初始化块。初始化块只有在创建Java对象时隐式执行，而且在执行构造器之前执行。</p>
<p>初始化块和构造器的作用非常相似，它们都用于对Java对象执行指定的初始化操作，但 它们之间依然存在一些差异。</p>
<p>普通初始化块、声明实例变量的指定的默认值都可以认为是对象的初始化代码，它们的执行顺序与源程序中的排列顺序相同。</p>
<p>当Java创建一个对象时，系统先为该对象的所有实例分配内存（前提是该类已经加载过了），接着程序开始对这些实例变量执行初始化，其初始化的执行顺序是：先执行初始化块或声明实例变量指定的初始值（这两个地方指定初始值的顺序允许与它们在源代码中的排序顺序相同），再执行构造器里指定的初始值。</p>
<h3 id="5-9-2-初始化块和构造器"><a href="#5-9-2-初始化块和构造器" class="headerlink" title="5.9.2 初始化块和构造器"></a>5.9.2 初始化块和构造器</h3><p>从某种程度上来看，初始化块是构造器的补充，初始化块总是在构造器执行之前执行。系统同样可以使用初始化块来进行对象的初始化操作。</p>
<p>与构造器不同的是，初始化块是一段固定执行的代码，它不能接收任何参数。因此初始化块对同一个类的所有对象所进行的初始化处理完全不同。基于这个原因，不难发现初始化块的基本用法，如果有一段初始化代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到初始化块中。</p>
<p>实际上初始化块是一个假象，使用javac命令编译Java类后，该Java类中的初始化块会消失——初始化块中代码会被“还原”到每个构造器中，且位于构造器所有代码的前面。</p>
<p>与构造器类似，创建一个Java对象时，不仅会执行该类的普通初始化块和构造器，而且系统会一直上溯到java.lang.Object类，先执行java.lang.Object类的初始化块，开始执行java.lang.Object的构造器，依次向下执行其父类的初始化块，开始执行其父类的构造器……最后才执行该类的初始化块和构造器，返回该类的对象。</p>
<p>除此之外，如果希望类加载后对整个类进行某些初始化操作，此时需要使用static关键字来修饰初始化块，使用static修饰的初始化块被称为静态初始化块。</p>
<h3 id="5-9-3-静态初始化块"><a href="#5-9-3-静态初始化块" class="headerlink" title="5.9.3 静态初始化块"></a>5.9.3 静态初始化块</h3><p>如果定义初始化块时使用了static修饰符，则这个初始化块就变成了静态初始化块，也被称为类初始化块（普通初始化块负责对对象执行初始化，类初始化块负责对类进行初始化）。静态初始化块是类相关的。系统将在类初始化阶段静态初始化块，而不是在创建对象时才执行。因此静态初始化块总是比普通初始化块先执行。</p>
<p>静态初始化块是类相关的，用于对整个类进行初始化处理，通常用于对类变量执行初始化处理。静态初始化块不能对实例变量进行初始化处理。</p>
<p>静态初始化块也被称为类初始化块，也属于类的静态成员，同样需要遵循静态成员不能访问非静态成员的规则，因此静态初始化块不能访问非静态成员，包括不能访问实例变量和实例方法。</p>
<p>与普通初始化块类似的是，系统在类初始化阶段执行静态初始化时，不仅会执行本类的静态初始化块，而且还会一直上溯到java.lang.Object类（如果它包含静态初始化块），先执行java.lang.Object类的静态初始化块（如果有），然后执行其父类的静态初始化块……最后才执行该类的静态初始化块，经过这个过程，才完成了该类的初始化过程。只有当类初始化完成后，才可以在系统中使用这个类，包括访问这个类的类方法、类变量或者用这个类来创建实例。</p>
<p>静态初始化块和声明静态成员变量时所指定的初始值都是该类的初始化代码，它们的执行顺序与源程序中的排列顺序相同。</p>
<h2 id="5-10-本章小结"><a href="#5-10-本章小结" class="headerlink" title="5.10 本章小结"></a>5.10 本章小结</h2><h1 id="第6章-面向对象（下）"><a href="#第6章-面向对象（下）" class="headerlink" title="第6章 面向对象（下）"></a>第6章 面向对象（下）</h1><p>Java为8个基本类型提供了对应的包装类，通过这些包装类可以把8个基本类型的值包装成对象使用，允许把基本类型值赋给对应的包装类引用变量，也允许把 包装类对象直接赋给对应的基本类型变量。</p>
<p>Java提供了final关键字来修饰变量、方法和类，系统不允许为final变量重新赋值，子类不允许覆盖父类的final方法，final类不能派生子类。通过使用final关键字，允许Java实现不可变类，不可变类会让系统更加安全。</p>
<p>abstract和interface两个关键字分别用于定义抽象类和接口，抽象类和接口都是从多个子类中抽象出来的共同特征。但抽象类主要作为多个类的模板，而接口则定义了多类应该遵循的规范。Lambda表达式。enum关键字用于创建枚举类型，枚举类是一种不能自由创建对象的类，枚举类的对象在定义类时已经固定下来。</p>
<p>对象在内存中的运行机制，对象的几种引用方式，垃圾回收机制如何处理不同引用的对象，jar命令创建JAR包。</p>
<h2 id="6-1-Java-8增强的包装类。"><a href="#6-1-Java-8增强的包装类。" class="headerlink" title="6.1 Java 8增强的包装类。"></a>6.1 Java 8增强的包装类。</h2><p>Java是面向对象的程序语言，但它包含了8种基本数据类型，这8种基本数据类型不支持面向对象的编程机制，基本数据类型的数据也不具备“对象”的特性：没有成员变量、方法可以被调用。Java之所以提供这8种基本数据类型，主要是为了照顾程序员的传统习惯。</p>
<p>这8种基本数据类型带来了一定的方便性，例如可以进行简单、有效的常规数据处理。但在某些时候，基本数据类型会有一些制约，例如所有引用类型变量都继承了Object类，都可当成Object类型变量使用。但基本数据类型变量就不可以，如果有个方法需要Object类型的参数，但实际需要的值却是2、3等数值，这就可能比较难处理。</p>
<p>为了解决8种基本数据类型不能当成Object类型变量使用的问题，Java提供了包装类(Wrapper Class)的概念，为8种基本数据类型分别定义了相应的引用类型，并称之为基本数据类型的包装类。</p>
<p>包装类可以实现基本类型变量和字符串之间的转换，把字符串类型的值转换为基本类型的值。</p>
<ul>
<li>利用包装类提供的parseXxx(String s)静态方法（除了Character之外的所有包装类都提供了该方法。）</li>
<li>利用包装类提供的Xxx(String s)构造器。</li>
</ul>
<p>String类提供了多个重载ValueOf()方法，用于将基本类型变量转换成字符串。</p>
<p>如果把基本类型变量转换成字符串，还有一种更简单的方法：将基本类型变量和””进行连接运算，系统会自动把基本类型变量转换成字符串。</p>
<p>此处需要指出的是，虽然包装类型的变量是引用数据类型，但包装类型的值可以与数值类型的值进行比较，这种比较是直接取出包装类实例所包装的值来进行比较。</p>
<p>两个包装类的实例进行比较的情况比较复杂，因为包装类的实例实际上是 引用类型，只有两个包装类引用指向同一个对象时才会返回true。</p>
<p>自动装箱，可以直接把一个基本类型值赋给一个包装类实例。</p>
<p>Java7为所有的包装类都提供了一个静态的compare(xxx val1, xxx val2)方法，这样开发者就可以通过包装类提供的compare(xxx val1, xxx val2)方法来比较两个基本类型值的大小，包括比较l两个boolean类型值，两个boolean类型值比较时，true&gt;false。</p>
<p>Java7还为Charcater包装类增加了大量的工具方法来对一个字符进行判断。</p>
<p>Java8再次增强了这些包装类的功能，其中一个重要的增强就是支持无符号算术运算。Java8为整型包装类增加了支持无符号运算的方法。Java8为Integer、Long增加了如下方法。</p>
<ul>
<li>static String toUnsignedString(int/long i)：该方法将指定int或long型整数转换为无符号整数对应的字符串。</li>
<li>static String toUnsignedString(int i/long, int radix)：该方法将指定int或long型整数转换为指定进制的无符号整数对应的字符串。</li>
<li>static xxx parseUnsignedXxx(String s)：该方法将指定字符串解析成无符号整数。当调用类为Integer时，xxx代表int，;当调用类是Long时，xxx代表long。</li>
<li>static int compareUnsigned(xxx x, xxx y)：该方法将x、y两个整数转换为无符号整数后比较大小。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表 long。</li>
<li>static long divideUnsigned(long dividend, long divisor)：该方法将x、y两个整数转换为无符号整数后计算它们相除的商。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表long。</li>
<li>static long remainderUnsigned(long dividend, long divisor)：该方法将x、y两个整数转换为无符号整数后计算它们相除的余数。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表long。</li>
</ul>
<p>Java8还为Byte、Short增加了toUnsignedInt(xxx x)、toUnsignedLong(yyy x)两个方法，这两个方法用于将指定byte或short类型的变量或值转换成无符号的int或long值。</p>
<h2 id="6-2-处理对象"><a href="#6-2-处理对象" class="headerlink" title="6.2 处理对象"></a>6.2 处理对象</h2><p>Java对象都是Object类的实例，都可直接调用该类中定义的方法，这些方法提供了处理Java对象的通用方法。</p>
<h3 id="6-2-1-打印对象和toString方法"><a href="#6-2-1-打印对象和toString方法" class="headerlink" title="6.2.1 打印对象和toString方法"></a>6.2.1 打印对象和toString方法</h3><p>toString()方法是Object类里的一个实例方法，所有的Java类都是Object类的子类，  因此所有的Java对象都具有toString()方法。</p>
<p>所有的Java对象都可以和字符串进行连接运算，当Java对象和字符串进行连接运算时，系统自动调用Java对象toString()方法的返回值和字符串进行连接运算。</p>
<p>toString()是一个非常特殊的方法，它是一个“自我描述”方法，该方法通常用于实现这样一个功能：当程序员直接打印该对象时，系统将会输出该对象的“自我描述”信息，用以告诉外界该对象具有的状态信息。</p>
<p>Object()类提供的toString()方法总是返回该对象实现类的“类名+@+hashCode”值，这个返回值并不能真正实现“自我描述”的功能，因此如果用户需要自定义类能实现“自我描述”的功能，就必须写Object类的toString()方法。</p>
<h3 id="6-2-2-和equals方法"><a href="#6-2-2-和equals方法" class="headerlink" title="6.2.2 ==和equals方法"></a>6.2.2 ==和equals方法</h3><p>Java程序中测试两个变量是否相等有两种方式：一种是利用==运算符，另一种是利用equals()方法。当使用 ==方法判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型（不一定要求数据类型严格相同），则只要两个变量的值相等，就将返回true。</p>
<p>但对于两个引用类型变量，只有它们指向同一个对象时，== 判断才会返回true。 == 不可用于比较类型上没有父子关系的两个对象。</p>
<p>JVM常量池保证相同字符串直接量只有一个，不会产生多个副本。</p>
<p>使用new String()创建的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存）内，不会放入常量池中。</p>
<p>但在很多时候，程序判断两个变量是否相等时，也希望有一种类似于“值相等”的判断规则，并不严格要求两个引用变量指向同一个对象。例如对于两个字符串变量，可能只是要求它们引用字符串对象里包含的字符串序列相同即可认为相等。此时就可以利用String对象的equals()方法来进行判断。</p>
<p>equals()方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量相等。但使用这个方法判断两个对象相等的标准与使用==运算符没有区别，同样要求两个引用变量指向同一个对象才会返回true。因此这个Object类提供的equals()方法没有太大的实际意义，如果希望采用自定义的相等标准，则可采用重写equals方法来实现。</p>
<p>Object默认提供的equals()只是比较对象的地址，即Object()类的equals()方法比较的结果与==运算符比较的结果完全相同。因此，在实际应用中常常需要重写equals()方法，重写equals()方法时，相等条件是由业务要求决定的，因此equals()方法的实现也是由业务要求决定的。</p>
<h2 id="6-3-类成员"><a href="#6-3-类成员" class="headerlink" title="6.3 类成员"></a>6.3 类成员</h2><p>static关键字修饰的成员就是类成员，类变量、类方法、静态初始化块，static关键字不能修饰构造器。static修饰的类成员属于整个类，不属于单个实例。</p>
<h3 id="6-3-1-理解类成员"><a href="#6-3-1-理解类成员" class="headerlink" title="6.3.1 理解类成员"></a>6.3.1 理解类成员</h3><p>在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员。static可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举），以static修饰的成员就是类成员。类成员属于整个类，而不属于单个对象。</p>
<p>类变量属于整个类，当系统第一次准备使用该类时，系统会为该类分配内存空间，类变量开始生效，直到该类被卸载，该类的类变量所占有的内存才被系统的垃圾回收机制回收。类变量生存范围几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。</p>
<p>类变量既可通过类来访问，也可通过类的对象来访问。但通过类的对象来访问类变量时，实际上并不是访问该对象所拥有的变量，因为系统创建该类的对象时，系统不会再为类变量分配内存，也不会再次对类变量进行初始化，也就是说，对象根本不拥有对应类的类变量。通过对象访问类变量只是一种假象，通过对象访问的依然是该类的类变量。当通过对象来访问类变量时，系统会在底层转换为通过该类来访问类变量。</p>
<p>对象并不持有类变量，类变量是由该类持有的，同一个类的所有对象访问类变量时，实际上访问的都是该类所持有的变量。因此，从程序运行表明来看，即可看到同一类的所有实例的类变量共享同一块内存区。</p>
<p>类方法也是类成员的一种，类方法也是属于类的，通常直接使用类作为调用者来访问类方法，但也可以使用对象来调用类方法。与类变量类似，即使使用对象来调用类方法，其效果也与采用类来调用类方法完全一样。</p>
<p>当使用实例来访问类成员时，实际上依然是委托给该类来访问类成员，因此即使某个实例为null，它也可以访问它所属类的类成员。</p>
<p>如果一个null对象访问实例成员（包括实例变量和实例方法），将会引发NullPointerException异常，因为null表明该实例根本不存在，既然实例不存在，那么它的实例变量和实例方法自然也不存在。</p>
<p>静态初始化也是类成员的一种，静态初始化块用于执行类初始化运作，在类的初始化阶段，系统会调用该类的静态初始化块来进行初始化。一旦该类初始化块结束后，静态初始化块永远不会获得执行的机会。</p>
<p>对static关键字而言，有一条非常重要的规则：类成员（包括方法、初始化块、内部类和枚举类）不能访问实例成员（包括成员变量、方法、初始化块、内部类和枚举类）。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大<br>，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。</p>
<h3 id="6-3-2-单例（Singleton）类"><a href="#6-3-2-单例（Singleton）类" class="headerlink" title="6.3.2 单例（Singleton）类"></a>6.3.2 单例（Singleton）类</h3><p>大部分时候把类的构造器定义成public访问权限，允许任何类自由创建该类的对象。但在某些时候，允许其他类自由创建该类的对象没有任何意义，还可能造成系统性能下降（因为频繁地创建对象、回收对象带来的系统开销问题）。</p>
<p>如果一个类始终只能创建一个实例，则这个类被称为单例类。</p>
<p>总之，在一些特殊场景下，要求不允许自由创建该类的对象，而只允许为该类创建一个对象。为了避免其他类自由创建该类的实例，应该把该类的构造器使用private修饰，从而把该类的所有构造器隐藏起来。</p>
<p>根据良好封装的原则：一旦把该类的构造器隐藏起来，就需要提供一个public方法作为该类的访问点，用于创建该类的对象，且该方法必须使用static修饰（因为调用该方法之前还不存在对象，因此调用该方法的不可能是对象，只能是类）。</p>
<p>除此之外，该类还必须缓存已经创建的对象，否则该类无法知道是否曾经创建过对象，也就无法保证只创建一个对象。为此该类需要使用一个成员变量来保存曾经创建的对象，因为该成员变量需要被上面的静态方法访问，故该成员变量必须使用static修饰。</p>
<h2 id="6-4-final修饰符"><a href="#6-4-final修饰符" class="headerlink" title="6.4 final修饰符"></a>6.4 final修饰符</h2><p>final关键字可用于修饰类、变量和方法，final关键字用于表示它修饰的类、方法和变量不可改变。</p>
<p>final修饰变量时，表示该变量一旦获得了初始值就不可被改变，final既可以修饰成员变量（包括类变量和实例变量），也可以修饰局部变量、形参。final修饰的变量不可被改变，一旦获得了初始值，该final变量的值就不能被重新赋值。</p>
<p>由于final变量获得初始值之后不能被重新赋值，因此final修饰成员变量和修饰局部变量时有一定的不同。</p>
<h3 id="6-4-1-final成员变量"><a href="#6-4-1-final成员变量" class="headerlink" title="6.4.1 final成员变量"></a>6.4.1 final成员变量</h3><p>成员变量是随类初始化或对象初始化而初始化的。当类初始化时，系统会为该类的类变量分配内存，并分配默认值；当创建对象时，系统会为该对象的实例变量分配内存，并分配默认值。当执行静态初始化时可以对类变量赋初始值；当执行普通初始化块、构造器时可对实例变量赋初始值。因此，成员变量的初始化可在定义该变量时指定默认值，也可以在初始化块、构造器中指定初始值。</p>
<p>对于final修饰的成员变量而言，一旦有了初始值，既不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的0、’\u0000’、false或null，这些成员变量也就完全失去了存在的意义。因此Java语法规定：final修饰的成员变量必须由程序员显式指定初始值。</p>
<p>归纳起来，final修饰的类变量、实例变量能指定初始值的地方如下。</p>
<ul>
<li>类变量：必须在静态初始化中指定初始值或声明时指定初始值，而且只能在两个地方的其中之一指定。</li>
<li>实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个地方的其中之一指定。</li>
</ul>
<p>final修饰的实例变量，要么在定义该实例变量时指定初始值，要么在普通初始化块或构造器中为该实例变量指定初始值。但需要注意的是，如果普通初始化块已经为某个实例变量指定了初始值，则不能再在构造器中为该实例变量指定初始值；final修饰的类变量，要么在定义该类变量时指定初始值，要么在静态初始化块中为该类变量指定初始值。</p>
<p>实例变量不能在静态初始化块中指定初始值，因为静态初始化块是静态成员，不可访问实例变量——非静态成员；类变量不能在普通初始化块中指定初始值，因为类变量在类初始化阶段已经被初始化了，普通初始化块不能对其重新赋值。</p>
<p>与普通成员变量不同的是，final成员变量（包括实例变量和类变量）必须由程序员显示初始化，系统不会对final成员进行隐式初始化。</p>
<p>如果打算在构造器、初始化块中对final成员变量进行初始化，则不要在初始化之前就访问成员变量的值。</p>
<h3 id="6-4-2-final局部变量"><a href="#6-4-2-final局部变量" class="headerlink" title="6.4.2 final局部变量"></a>6.4.2 final局部变量</h3><p>系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。因此使用final修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值。</p>
<p>如果final修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该final变量赋初始值，但只能一次，不能重复赋值；如果final修饰的局部变量在定义时已经指定默认值，则后面代码中不能再对该变量赋值。</p>
<p>使用final修饰的形参不能被赋值。</p>
<h3 id="6-4-3-final修饰基本类型变量和引用类型变量的区别"><a href="#6-4-3-final修饰基本类型变量和引用类型变量的区别" class="headerlink" title="6.4.3 final修饰基本类型变量和引用类型变量的区别"></a>6.4.3 final修饰基本类型变量和引用类型变量的区别</h3><p>当final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<h3 id="6-4-4-可执行“宏替换”的final变量"><a href="#6-4-4-可执行“宏替换”的final变量" class="headerlink" title="6.4.4 可执行“宏替换”的final变量"></a>6.4.4 可执行“宏替换”的final变量</h3><p>对一个final变量来说，不管它是类变量、实例变量，还是局部变量，只要该变量满足三个条件，这个final变量就不再是一个变量，而是相当于一个直接量。</p>
<ul>
<li>使用final修饰符修饰</li>
<li>在定义该final变量时指定了初始值</li>
<li>该初始值可以在编译时就被确定下来。</li>
</ul>
<p>final修饰符的一个重要用途就是定义“宏变量”。当定义final变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么这个final变量本质上就是一个“宏变量”，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。</p>
<p>除了上面那种为final变量赋直接量的情况外，如果被赋的表达式只是基本的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”处理。</p>
<p>Java会使用常量池来管理曾经用过的字符串直接量。</p>
<p>对于实例变量而言，既可以在定义该变量时赋初值，也可以在非静态初始化块、构造器中对它赋初值，在这三个地方指定初始值的效果基本一样。但对于final实例变量而言，只有在定义该变量时指定初始值才会有“宏变量”的效果。</p>
<h3 id="6-4-5-final方法"><a href="#6-4-5-final方法" class="headerlink" title="6.4.5 final方法"></a>6.4.5 final方法</h3><p>final修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用final修饰该方法。</p>
<p>Java提供的Object类里就有一个final方法:getClass()，因为Java不希望任何类重写这个方法，所以使用final把这个方法密封起来。但对于该类提供的toString()和equals()方法，都允许子类重写，因此没有使用final修饰它们。</p>
<p>对于一个private方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法——如果子类中定义一个与父类private方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。因此，使用final修饰一个private访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类型的方法。</p>
<p>final修饰的方法仅仅是不能被重写，并不是不能被重载。</p>
<p>6.4.6 final类</p>
<p>final修饰的类不可以有子类。</p>
<p>当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用final修饰这个类。</p>
<h3 id="6-4-7-不可变类"><a href="#6-4-7-不可变类" class="headerlink" title="6.4.7 不可变类"></a>6.4.7 不可变类</h3><p>不可变类（immuutable）类的意思是创建该类的实例后，该实例的实例变量是不可改变的。Java提供的8个包装类和java.lang.String类都是不可变类，当它们创建实例后，其实例的实例变量不可改变。</p>
<p>如果需要创建自定义的不可变类，可遵循如下规则。</p>
<ul>
<li>使用private和final修饰符来修饰该类的成员变量</li>
<li>提供带参数的构造器，用于根据参数来初始化类里的成员变量</li>
<li>仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，因为普通方法无法修改final修饰的成员变量。</li>
<li>如果没必要，重写Object类的hashCode()和equals()方法。equals()方法根据关键成员变量来作为两个对象是否相等的标准，除此之外，还应该保证两个用eqauals()方法判断为相等的对象hashCode()也相等。</li>
</ul>
<p>与不可变类对应的是可变类，可变类的含义是该类的实例变量是可变的。大部分时候所创建的类都是可变类，特别是JavaBean，因为总是为其实例变量提供了setter和getter方法。</p>
<p>与不可变类相比，不可变类的实例在整个生命周期中永远处于初始化状态，它的实例变量不可改变。因此，对不可变类的实例的控制将更加简单。</p>
<p>前面介绍final关键字时提到，当使用final修饰引用类型变量时，仅表示这个引用类型变量不可被重新赋值，但引用类型变量所指向的对象依然可以改变。</p>
<p>如果需要设计一个不可变类，尤其要注意其引用类型的成员变量，如果引用类型的成员变量的类是可变的，就必须采取必要的措施来保护该成员变量所引用的对象不会被修改，这样才能创建真正的不可变类。</p>
<h3 id="6-4-8-缓存实例的不可变类"><a href="#6-4-8-缓存实例的不可变类" class="headerlink" title="6.4.8 缓存实例的不可变类"></a>6.4.8 缓存实例的不可变类</h3><p>不可变类的实例状态不可改变，可以很方便地被多个对象所共享。如果程序经常需要使用相同的不可变类实例，则应该考虑缓存这种不可变类的实例。毕竟重复创建相同的对象没有太大的意义，而且加大系统开销。如果可能，应该将已经创建的不可变类的实例进行缓存。</p>
<h2 id="6-5-抽象类"><a href="#6-5-抽象类" class="headerlink" title="6.5 抽象类"></a>6.5 抽象类</h2><p>当编写一个类时，常常会为该类定义一些方法，这些方法用以描述该类的行为方式，那么这些方法都有具体的方法体。但在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确地知道这些子类如何实现这些方法。</p>
<p>抽象方法是只有方法签名，没有方法实现的方法。</p>
<h3 id="6-5-1-抽象方法和抽象类"><a href="#6-5-1-抽象方法和抽象类" class="headerlink" title="6.5.1 抽象方法和抽象类"></a>6.5.1 抽象方法和抽象类</h3><p>抽象方法和抽象类必须使用abstract修饰符来定义，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</p>
<p>抽象方法和抽象类的规则如下，</p>
<ul>
<li>抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器来创建抽象类的实例。即使抽象类里不包含抽象方法、这个抽象类也不能创建实例。</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li>
<li>含有抽象方法的类（包括直接定义一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类。</li>
</ul>
<p>归纳起来，抽象类可用“有得有失”4个字来描述。“得”指的是抽象类多了一个能力：抽象类可以包含抽象方法；“失”指的是抽象类失去了一个能力：抽象类不能用于创建实例。</p>
<p>定义抽象方法只需在普通方法上增加abstract修饰符，并把普通方法的方法体（也就是方法后花括号括起来的部分）全部去掉，并在方法后增加分号。</p>
<p>抽象方法和空方法体的方法不是同一个概念。</p>
<p>定义抽象类只需在普通类上增加abstract修饰符即可。甚至一个普通类（没有包含抽象方法的类）增加abstract修饰符后也将变成抽象类。</p>
<p>利用抽象类和抽象方法的优势，可以更好地发挥态的优势，使得程序更加灵活。</p>
<p>当使用abstract修饰类时，表明这个只能被继承；当使用abstract修饰方法时，表明这个方法必须由子类提供实现（即重写）。而final修饰的类不能被继承，final修饰的方法不能被重写。因此，final和abstract永远不能同时使用。</p>
<p>abstract不能用于修饰成员变量，不能用于修饰局部变量，即没有抽象变量、没有抽象成员变量等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器。</p>
<p>除此之外，当使用static修饰一个方法时，表明这个方法属于该类本身，即通过类就可以调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法出现错误（调用了一个没有方法体的方法肯定会引起错误）。因此static和abstract不能同时修饰某个方法，即没有所谓的类抽象方法。</p>
<p>static和abstract并不是绝对互斥的，static和abstract虽然不能同时修饰某个方法，但它们可以同时修饰内部类。</p>
<p>abstract关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此abstract方法不能定义为private访问权限，即private和abstract不能同时修饰方法。</p>
<h3 id="6-5-2-抽象类的作用"><a href="#6-5-2-抽象类的作用" class="headerlink" title="6.5.2 抽象类的作用"></a>6.5.2 抽象类的作用</h3><p>抽象类不能创建实例，只能当成父类来被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类设计的随意性。</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>如果编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式，模板模式也是十分常见且简单的设计模式之一。</p>
<p>模板模式在面向对象的软件中很常用，其原理简单，实现也很简单。下面是模板模式的一些简单规则。</p>
<ul>
<li>抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现。</li>
<li>父类中可能包含需要其它系列方法的方法，这些被调用方法既可以由父类实现，也可以由其子类实现。父类里提供的方法只是定义了一个通用算法,其实现也许并不完全自身实现，而必须依赖于其子类的辅助。</li>
</ul>
<h2 id="6-6-Java-8改进的接口"><a href="#6-6-Java-8改进的接口" class="headerlink" title="6.6 Java 8改进的接口"></a>6.6 Java 8改进的接口</h2><p>抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（interface），接口里不能包含普通方法，接口里的所有方法都是抽象方法。Java 8对接口进行了改进，允许在接口中定义默认方法，默认方法可以提供方法实现。</p>
<h3 id="6-6-1-接口的概念"><a href="#6-6-1-接口的概念" class="headerlink" title="6.6.1 接口的概念"></a>6.6.1 接口的概念</h3><p>接口是从多个相似类中抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现分离的设计哲学。 </p>
<p>让规范和实现分离正是接口的好处，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。</p>
<h3 id="6-6-2-Java8中接口的定义"><a href="#6-6-2-Java8中接口的定义" class="headerlink" title="6.6.2 Java8中接口的定义"></a>6.6.2 Java8中接口的定义</h3><p>和类定义不同，定义接口不再使用class关键字，而是使用interface关键字。接口定义的基本语法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[修饰符] interface 接口名 extends 父接口1, 父接口2...</div><div class="line">&#123;</div><div class="line">    零到多个常量定义...</div><div class="line">    零到多个抽象方法定义...</div><div class="line">    零到多个内部类、接口、枚举定义...</div><div class="line">    零到多个默认方法或类方法定义...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对上面语法的详细说明如下，</p>
<ul>
<li>修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口。</li>
<li>接口名与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵循Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>在上面语法定义中，只有在Java8以上的版本中才允许在接口中定义默认方法、类方法。</p>
<p>由于接口是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态变量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）定义。</p>
<p>对比接口和类的定义方式，不难发现接口的成员比类里的成员少了两种，而且接口里的成员变量只能是静态常量，接口里的方法只能是抽象方法、类方法或默认方法。</p>
<p>接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法、内部类和内部枚举都是public访问权限。定义接口时，可以省略访问控制修饰符，如果指定访问控制修饰符，则只能使用public访问控制修饰符。</p>
<p>对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static和final两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用public static final修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。</p>
<p>系统自动为接口里定义的成员变量增加public static final修饰符。</p>
<p>接口里的方法只能是抽象方法、类方法和默认方法，因此如果不是定义默认方法，系统将自动为普通方法增加abstract修饰符；定义接口里的普通方法不管是否使用public abstract修饰符，接口里的普通方法总是使用public abstract来修饰。接口里的普通方法不能有方法实现（方法体）；但类方法、默认方法都必须有方法实现（方法体）。</p>
<p>接口里定义的内部类、内部接口、内部枚举默认都采用public static两个修饰符，不管定义时是否指定这两个修饰符，系统都自动使用public static对它们进行修饰。</p>
<p>Java 8允许在接口中定义默认方法，默认方法必须使用default修饰，该方法不能使用static修饰，无论程序是否指定，默认方法总是使用public修饰——如果开发者没有指定public，系统会自动为默认方法增加public修饰符。由于默认方法并不没有static修饰，因此不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法。</p>
<p>Java 8允许在接口中定义类方法，类方法必须使用static修饰，该方法不能使用default修饰，无论程序是否指定，类方法总是使用public修饰——如果开发者没有指定public，系统会自动为类方法添加public修饰符。类方法可以直接使用接口来调用。</p>
<p>接口里的成员变量默认是使用public static final修饰的，因此即使另一类处于不同包下，也可以通过接口来访问接口里的成员变量。</p>
<p>从某个角度来看，接口可被当成一个特殊的类，因此一个Java源文件里最多只能有一个public接口，如果Java源文件里定义了一个public接口，则该源文件的主文件名必须与该接口名相同。</p>
<h3 id="6-6-3-接口的继承"><a href="#6-6-3-接口的继承" class="headerlink" title="6.6.3 接口的继承"></a>6.6.3 接口的继承</h3><p>接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。和类继承相似，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。</p>
<p>一个接口继承多个父接口时，多个父接口排在extends关键字之后，多个父接口之间以英文逗号（,）隔开。</p>
<h3 id="6-6-4-使用接口"><a href="#6-6-4-使用接口" class="headerlink" title="6.6.4 使用接口"></a>6.6.4 使用接口</h3><p>接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其实现类的对象。除此之外，接口的主要用途就是被实现类实现。归纳起来，接口主要有如下用途。</p>
<ul>
<li>定义变量，也可用于进行强制类型转换。</li>
<li>调用接口中定义的常量。</li>
<li>被其他类实现。</li>
</ul>
<p>一个类可以实现一个或多个接口，继承使用extends关键字，实现则使用 implements关键字。因为一个类可是现实多个接口，这也是Java为单继承灵活性不足所做的补充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符] class 类名 extends 父类 implements 接口1, 接口2...</div><div class="line">&#123;</div><div class="line">    类体部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量（成员变量）、方法（包括抽象方法和默认方法）。</p>
<p>让类实现接口需要类定义后增加implements部分，当需要实现多个接口时，多个接口之间以英文逗号（,）隔开。一个类可以继承一个父类，并同时实现多个接口，implements部分必须放在extends部分之后。</p>
<p>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</p>
<p>一个类实现某个接口时，该类将会获得接口中定义的常量（成员变量）、方法等，因此可以把实现接口理解为一种特殊的继承，相当于实现类继承了一个彻底抽象的类（相当于除了默认方法外，所有方法都是抽象方法的类）。</p>
<p>实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（相当于实现类）重写父类方法时访问权限只能更大或相等，所以实现类实现接口里的方法只能使用public访问权限。</p>
<p>接口不能显示继承任何类，但所有接口类型的引用变量都可以直接赋给Object类型的引用变量。</p>
<h3 id="6-6-5-接口和抽象类"><a href="#6-6-5-接口和抽象类" class="headerlink" title="6.6.5 接口和抽象类"></a>6.6.5 接口和抽象类</h3><p>接口和抽象类很像，它们都具有如下特征。</p>
<ul>
<li>接口和抽象类都不能被实力化，它们都位于继承树的顶端，用于被其他类实现和继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li>
</ul>
<p>但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。</p>
<p>接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p>
<p>从某种程度来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响是辐射式的，导致系统中大部分类都需要改写。</p>
<p>抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供的实现方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。</p>
<p>除此之外，接口和抽象类在用法上也存在如下差别。</p>
<ul>
<li>接口里只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li>
<li>接口里不能定义静态方法；抽象类里可以定义静态方法。</li>
<li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里既可以定义普通成员变量，也可以定义静态常量。</li>
<li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成抽象类的初始化操作。</li>
<li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li>
</ul>
<h3 id="6-6-6-面向接口编程"><a href="#6-6-6-面向接口编程" class="headerlink" title="6.6.6 面向接口编程"></a>6.6.6 面向接口编程</h3><p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。</p>
<p>基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p>
<ol>
<li><p>简单工厂模式</p>
</li>
<li><p>命令模式</p>
</li>
</ol>
<h2 id="6-7-内部类"><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2><p>大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有的地方也叫嵌套类），包含内部类的类也被称为外部类（有的地方也叫宿主类）。</p>
<p>内部类主要有以下作用：</p>
<ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以互相访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量。</li>
<li>匿名内部类适合于创建那些仅需要一次使用的类。</li>
</ul>
<p>从语法角度来看，定义内部类与定义外部类的语法大致相同，内部类除了需要定义在其他类里之外，还存在如下两点区别。</p>
<ul>
<li>内部类比外部类可以多使用三个修饰符：private、protected、static——外部类不可以使用这三个修饰符。</li>
<li>非静态内部类不能拥有静态成员。</li>
</ul>
<h3 id="6-7-1-非静态内部类"><a href="#6-7-1-非静态内部类" class="headerlink" title="6.7.1 非静态内部类"></a>6.7.1 非静态内部类</h3><p>定义内部类非常简单，只要把一个类放在另一个类内部定义即可。此处的“内部类”包括类中的任何位置，甚至在方法中也可以定义内部类（方法里定义的内部类被称为局部内部类）。内部类定义语法格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class OuterClass</div><div class="line">&#123;</div><div class="line">    //此处可以定义内部类</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大部分时候，内部类都被作为成员内部类定义，而不是作为局部内部类。成员内部类是一种与成员变量、方法、构造器和初始化相似的类成员；局部内部类和匿名内部类则不是类成员。</p>
<p>成员内部类分为两种：静态内部类和非静态内部类，使用static修饰的成员内部类是静态内部类，没有使用static修饰的成员内部类是非静态内部类。</p>
<p>外部类的上一级程序单元是包，所以它只有2个作用域：同一个包内和任何位置。因此只需2种访问权限：包访问权限和公开访问权限，正好对应省略访问控制符和public访问控制符。省略访问控制符是包访问权限，即同一个包中的其他类可以访问省略访问控制的成员。因此，如果一个外部类不使用任何访问控制修饰符，则只能被同一个包中其他类访问。而内部类的上一级程序单元是外部类，它所具有4个作用域：同一个类、同一个包、父子类和任何位置，因此可以设置4种访问权限。</p>
<p>在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用（当调用非静态内部类的实例方法时，必须有一个非静态内部类实例，非静态内部类实例必须寄生在外部类实例里）。</p>
<p>当在非静态内部类的方法内访问某个变量时，系统优先在该方法内查找是否存在该名字的局部变量，如果存在就使用该变量；如果不存在，则到该方法所在的内部类中查找是否存在该名字的成员变量，如果存在则使用该成员变量；如果不存在，则到该内部类所在的外部类中查找是否存在该名字的成员变量，如果存在则使用该成员变量；如果依然不存在，系统将出现编译错误：提示找不到该变量。</p>
<p>因此，如果外部类成员变量、内部类成员变量与内部类里方法的局部变量相同，则可通过使用this、外部类名.this作为限定来区分。</p>
<p>非静态内部类的成员可以访问外部类的private成员，但反过来就不成立了。非静态内部类的成员只在非静态内部类范围内是可知的，并不能被外部类直接使用。如果外部类要访问非静态内部类的成员，则必须显式创建非静态内部类对象来调用访问其实例成员。</p>
<p>非静态内部类对象必须寄存在外部类对象里，而外部类对象则不必一定有非静态内部类对象寄生其中。如果存在一个非静态内部类对象，则一定存在一个被它寄生的外部类对象。但外部类对象存在时，外部类对象里不一定寄生了非静态内部类对象。因此外部类对象访问非静态内部类成员时，可能非静态普通内部类对象根本不存在！而非静态内部类对象访问外部类成员时，外部类对象一定存在。</p>
<p>根据静态成员不能访问非静态成员的规则，外部类的静态方法、静态代码不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例等。总之，不允许在外部类的静态成员中直接使用非静态内部类。</p>
<p>Java不允许在非静态内部类里定义静态成员。</p>
<p>非静态内部类里不能有静态方法、静态成员变量、静态初始化块。</p>
<p>非静态内部类里不可以有静态初始化块，但可以包含普通初始化块。非静态内部类普通初始化块的作用与外部类初始化块的作用完全相同。</p>
<h3 id="6-7-2-静态内部类"><a href="#6-7-2-静态内部类" class="headerlink" title="6.7.2 静态内部类"></a>6.7.2 静态内部类</h3><p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。</p>
<p>static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象，外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关，因此static关键字不可修饰外部类，但可修饰内部类。</p>
<p>静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员，即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。</p>
<p>静态内部类是外部类的类相关的，而不是外部类的对象相关的。静态内部类对象不是寄生在外部类的实例中，而是寄生在外部类的类本身中。当静态内部类对象存在时，并不存在一个被它寄生的外部类对象，静态内部类对象只有外部类的类引用，没有持有外部类对象的引用。</p>
<p>静态内部类是外部类的一个静态成员，因此外部类的所有方法、所有初始化块中可以使用静态内部类来定义变量、创建对象等。</p>
<p>外部类依然不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。</p>
<p>Java还允许在接口里定义内部类，接口里定义的内部类默认使用public static修饰，接口内部类只能是静态内部类。</p>
<p>如果为接口内部类指定访问控制符，则只能指定public访问控制符；如果定义接口内部类时省略访问控制符，则该内部类默认是public访问控制权限。</p>
<p>接口里的内部接口是接口的成员，因此系统默认添加public static两个修饰符。如果定义接口里的内部接口时指定访问控制符，则只能使用public修饰符。当然，定义接口里的内部接口意义不大啊，因为接口的作用是定义一个公共规范（暴露出来供大家使用），如果把这个接口定义成一个内部接口，那么意义何在呢？在实际开发过程中很少见到这种应用场景。</p>
<h3 id="6-7-3-使用内部类"><a href="#6-7-3-使用内部类" class="headerlink" title="6.7.3 使用内部类"></a>6.7.3 使用内部类</h3><p>定义类的主要作用是定义变量、创建实例和作为父类被继承。定义内部类的作用也如此，但使用内部类定义变量和创建实例则与外部类存在一些小小的差异。</p>
<ol>
<li>在外部类内部使用内部类</li>
</ol>
<p>在外部类内部使用内部类时，与平常使用普通类没有太大的区别。一样可以直接通过内部类类名来定义变量，通过new调用内部类构造器来创建实例。</p>
<p>唯一存在的一个区别是：不要在外部类的静态成员（包括静态方法和静态初始化块）中使用非静态内部类，因为静态成员不能访问非静态成员。</p>
<p>在外部类内部定义内部类的子类与平常定义子类也没有太大的区别。</p>
<ol>
<li>在外部类以外使用非静态内部类</li>
</ol>
<p>如果希望在外部类以外的地方访问内部类（包括静态和非静态两种），则内部类不能使用private访问控制权限，private修饰的内部类只能在外部类内部使用。对于使用其他访问控制符的内部类，则能在访问控制符对应的访问权限内使用。</p>
<ul>
<li>省略访问控制符的内部类，只能被与外部类处于同一个包中的其他类所访问。</li>
<li>使用protected修饰的内部类，可被与外部类处于同一个包中的其他类和外部类的子类所访问。</li>
<li>使用public修饰的内部类，可以在任何地方被访问。</li>
</ul>
<p>在外部类以外的地方定义内部类（包括静态和非静态两种）变量的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterClass.InnerClass varName</div></pre></td></tr></table></figure>
<p>从语法格式可以看出，在外部类以外的地方使用内部类时，内部类完整的类名应该是OuterClass.InnerClass。如果外部类有包名，则还应该增加包名前缀。</p>
<p>由于非静态内部类的对象必须寄生在外部类对象里，因此创建非静态内部类对象之前，必须先创建其他外部类对象。在外部类以外的地方创建非静态内部类实例的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterInstance.new InnerConstructor()</div></pre></td></tr></table></figure>
<p>在外部类以外的地方创建非静态内部类实例必须使用外部类实例和new来调用非静态内部类的构造器。</p>
<p>当创建一个子类时，子类构造器总会调用父类的构造器，因此在创建非静态内部类的子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类构造器时，必须存在一个外部类对象。</p>
<p>非静态内部类的子类不一定是内部类，它可以是一个外部类。但非静态内部类的子类实例一样需要保留一个引用，该引用指向其父类所在外部类的对象。也就是说，如果有一个内部类子类的对象存在，则一定存在与之对应的外部类对象。</p>
<ol>
<li>在外部类以外使用静态内部类</li>
</ol>
<p>因为静态内部类是外部类类相关的，因此创建静态内部类对象时无须创建外部类对象。在外部类以外的地方创建静态内部类实例的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new OuterClass.InnerConstructor()</div></pre></td></tr></table></figure>
<p>不管是静态内部类还是非静态内部类，它们声明变量的语法完全一样。区别是在创建内部类对象时，静态内部类只需要使用外部类即可调用构造器，而非静态内部类必须使用外部对象来调用构造器。</p>
<p>调用静态内部类构造器时无须使用外部类对象，所以创建静态内部类的子类也比较简单。</p>
<p>当定义一个静态内部类时，其外部类非常像一个包空间。</p>
<p>相比之下，使用静态内部类比使用非静态内部类要简单很多，只要把外部类当成静态内部类的包空间即可。因此当程序员要使用内部类时，应该优先考虑使用静态内部类。</p>
<p>内部类的类名不再是简单地由内部类的类名组成，它实际上还把外部类的类名作为一个命名空间，作为内部类类名的限制。因此子类中的内部类和父类中的内部类不可能完全同名，即使二者所包含的内部类的类名相同，但因为它们所处的外部类空间不同，所以它们不可能完全同名，也就不可能重写。</p>
<h3 id="6-7-4-局部内部类"><a href="#6-7-4-局部内部类" class="headerlink" title="6.7.4 局部内部类"></a>6.7.4 局部内部类</h3><p>如果把一个内部类放在方法里定义，则这个内部类就是一个局部内部类，局部内部类仅在方法里有效。由于局部内部类不能在外部类的方法以外的地方使用，因此局部内部类也不能使用访问控制符和static修饰符修饰。</p>
<p>对于局部成员而言，不管是局部变量还是局部内部类，它们的上一级程序单元都是方法，而不是类，使用static修饰它们没有任何意义。因此，所有的局部成员变量都不能使用static修饰。不仅如此，因为局部成员的作用域是所在方法，其他程序永远也不可能访问另一个方法中的局部成员，所以所有的局部成员都不能使用访问控制符修饰。</p>
<p>如果需要用局部类定义变量、创建实例或派生类，那么都只能在局部类所在的方法内进行。</p>
<h3 id="6-7-5-Java-8-改进的匿名内部类"><a href="#6-7-5-Java-8-改进的匿名内部类" class="headerlink" title="6.7.5 Java 8 改进的匿名内部类"></a>6.7.5 Java 8 改进的匿名内部类</h3><p>匿名内部类时候创建那种只需要一次使用的类，例如前面介绍模式时所需要的Command对象。匿名内部类的语法有点奇怪，创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。</p>
<p>匿名内部类的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new 实现接口[] | 父类构造器(实参列表)</div><div class="line">&#123;</div><div class="line">    //匿名内部类的类体部分</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面定义可以看出，匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口。</p>
<p>关于匿名内部类还有如下两条规则。</p>
<ul>
<li>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因此不允许将匿名内部类定义成抽象类。</li>
<li>匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</li>
</ul>
<p>最常用的创建匿名内部类的方式是需要创建某个接口类型的对象。</p>
<p>定义匿名内部类无须class关键字，而是在定义匿名内部类时直接生成该匿名内部类对象。</p>
<p>由于匿名内部类不能是抽象类，所以匿名内部类必须实现它的抽象父类或者接口里包含的所有抽象方法。</p>
<p>当通过时间接口来创建匿名内部类时，匿名内部类也不能显示创建构造器，因此匿名内部类只有一个隐式的无参数构造器，故new接口名后的括号里不能传入参数值。</p>
<p>但如果通过继承父类来创建匿名内部类时，匿名内部类将拥有和父类相似的构造器，此处的相似指的是拥有相同的形参列表。</p>
<p>Java 8 ，如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。</p>
<p>effectively final ， 对于被匿名内部类访问的局部变量，可以用final修饰，也可以不用final修饰，但必须按照有final修饰的方式来用——也就是一次赋值后，以后不能重新赋值。</p>
<h2 id="6-8-Java-8新增的Lambda表达式"><a href="#6-8-Java-8新增的Lambda表达式" class="headerlink" title="6.8 Java 8新增的Lambda表达式"></a>6.8 Java 8新增的Lambda表达式</h2><p>Lambda表达式是Java 8的重要更新，也是一个被广大开发者期待已久的新特性。Lambda表达式支持将代码块作为方法参数，Lambda表达式允许使用简洁的代码来创建只有一个抽象方法的接口（这种接口被称为函数式接口）的实例。</p>
<h3 id="6-8-1-Lambda表达式入门"><a href="#6-8-1-Lambda表达式入门" class="headerlink" title="6.8.1 Lambda表达式入门"></a>6.8.1 Lambda表达式入门</h3><p>Lambda表达式完全可用于简化匿名内部类对象。</p>
<p>当使用Lambda表达式代替匿名内部类创建对象时，Lambda表达式的代码块将会代替抽象方法的方法体，Lambda表达式就相当一个匿名方法。</p>
<p>Lambda表达式的主要作用是代替匿名内部类的繁琐语法。它由三部分组成。</p>
<ul>
<li>形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。</li>
<li>箭头（-&gt;）。必须通过英文中画线号和大于符号组成。</li>
<li>代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么这条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一条省略了return语句，Lambda表达式会自动返回这条语句的值。</li>
</ul>
<h3 id="6-8-2-Lambda表达式与函数式接口"><a href="#6-8-2-Lambda表达式与函数式接口" class="headerlink" title="6.8.2 Lambda表达式与函数式接口"></a>6.8.2 Lambda表达式与函数式接口</h3><p>Lambda表达式的类型，也被称为“目标类型（target type）”， Lambda表达式的目标类型必须是“函数式接口（functional interface）”。函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口的实例，则只需要实现一个抽象方法，在这种情况下即可采用Lambda表达式来创建对象，该表达式创建出来的对象的目标类型就是这个函数式接口。</p>
<p>由于Lambda表达式的结果就是被当成对象，因此程序中完全可以使用Lambda表达式进行赋值。</p>
<p>Runnable是Java提供的一个函数式接口。</p>
<p>Lambda表达式实现的是匿名方法——因此它只能实现特定函数式接口中的唯一方法。这意味着Lambda表达式有如下两个限制。</p>
<ul>
<li>Lambda表达式的目标类型必须是明确的函数式接口。</li>
<li>Lambda表达式只能为函数式接口创建对象。Lambda表达式只能实现一个方法，因此它只能为只有一个抽象方法的接口（函数式接口）创建对象。</li>
</ul>
<p>为了保证Lambda表达式的目标类型是一个明确的函数式接口，可以有如下三种常见方式。</p>
<ul>
<li>将Lambda表达式赋值给函数式接口类型的变量。</li>
<li>将Lambda表达式作为函数式接口类型的参数传给某个方法。</li>
<li>使用函数式接口对Lambda表达式进行强制类型转换。</li>
</ul>
<p>Java 8 在java.util.function包下定义了大量函数式接口，典型地包含如下4个接口。</p>
<ul>
<li>XxxFunction：这类接口中通常包含一个apply()抽象方法，该方法对参数进行处理、转换（apply()方法的处理逻辑由Lambda表达式来实现），然后返回一个新的值。该函数式接口通常用于对指定数据进行转换处理。</li>
<li>XxxConsumer：这类接口中通常含有一个accept()抽象方法，该方法与XxxFunction接口中的apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理结果。</li>
<li>XxxPredicate：这类接口中通常包含一个test()抽象方法，该方法通常用来对参数进行某种判断(test()方法的判断逻辑由Lambda表达式来实现)，然后返回一个boolean值。该接口通常用于判断参数是否满足特定条件，经常用于进行筛滤数据。</li>
<li>XxxSupplier：这类接口中通常包含一个getAsXxx()抽象方法，该方法不需要输入参数，该方法会按某种逻辑算法（getAsXxx()方法的逻辑算法由Lambda表达式来实现）返回一个数据。</li>
</ul>
<p>综上所述，Lambda表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例——这种语法避免了内部类的烦琐。</p>
<h3 id="6-8-3-方法引用与构造器引用"><a href="#6-8-3-方法引用与构造器引用" class="headerlink" title="6.8.3 方法引用与构造器引用"></a>6.8.3 方法引用与构造器引用</h3><p>如果Lambda表达式的代码只有一条代码，程序就可以省略Lambda表达式中代码块的花括号。不仅如此，如果Lambda表达式的代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用。</p>
<p>方法引用和构造器引用可以让Lambda表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号。</p>
<p>Lambda表达式支持如表所示的几种引用方式。</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>实例</th>
<th>说明</th>
<th>　对应的Lambda表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用类方法</td>
<td>类名::类方法</td>
<td>函数式接口中被实现方法的全部参数传给该类方法作为参数</td>
<td>(a,b,…)-&gt;类名.类方法(a,b,…)</td>
</tr>
<tr>
<td>引用特定对象的实例方法</td>
<td>特定对象::实例方法</td>
<td>函数式接口中被实现的全部参数传给该方法作为参数</td>
<td>(a,b,…)-&gt;特定对象.实例方法(a,b,…)</td>
</tr>
<tr>
<td>引用某类对象的实例方法</td>
<td>类名::实例方法</td>
<td>函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数</td>
<td>(a,b,…)-&gt;a.实例方法(b,…)</td>
</tr>
<tr>
<td>引用构造器</td>
<td>类名::new</td>
<td>函数式接口中被实现的全部参数传给该构造器作为参数</td>
<td>(a,b,…)-&gt;new 类名(a,b,…)</td>
</tr>
</tbody>
</table>
<ol>
<li>引用类方法</li>
<li>引用特定对象的实例方法</li>
<li>引用某类对象的实例方法</li>
<li>引用构造器</li>
</ol>
<h3 id="6-8-4-Lambda表达式与匿名内部类的联系和区别"><a href="#6-8-4-Lambda表达式与匿名内部类的联系和区别" class="headerlink" title="6.8.4 Lambda表达式与匿名内部类的联系和区别"></a>6.8.4 Lambda表达式与匿名内部类的联系和区别</h3><p>Lambda表达式是匿名类的一种简化，因此它可以部分取代匿名内部类的作用，Lambda表达式与匿名内部类存在如下相同点。</p>
<ul>
<li>Lambda表达式与匿名内部类一样，都可以直接访问“effectively final”的局部变量，以及外部类的成员变量（包括实例变量和类变量）。</li>
<li>Lambda表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认方法。</li>
</ul>
<p>Lambda表达式表达式与匿名内部类主要存在如下区别</p>
<ul>
<li>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可；但Lambda表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例；但Lambda表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的方法；但Lambdas表达式的代码块不允许调用接口中定义的默认方法。</li>
</ul>
<h3 id="6-8-5-使用Lambda表达式调用Arrays的类方法"><a href="#6-8-5-使用Lambda表达式调用Arrays的类方法" class="headerlink" title="6.8.5 使用Lambda表达式调用Arrays的类方法"></a>6.8.5 使用Lambda表达式调用Arrays的类方法</h3><p>Array类的有些方法需要Comparator、XxxOperator、XxxFunction等接口的实例，这些接口都是函数式接口，因此可以使用Lambda表达式来调用Arrays的方法。</p>
<h2 id="6-9-枚举类"><a href="#6-9-枚举类" class="headerlink" title="6.9 枚举类"></a>6.9 枚举类</h2><p>在某些情况下，一个类的对象是有限而且固定的，这种实例有限而且固定的类，在Java里被称为枚举类。</p>
<h3 id="6-9-1-手动实现枚举类"><a href="#6-9-1-手动实现枚举类" class="headerlink" title="6.9.1 手动实现枚举类"></a>6.9.1 手动实现枚举类</h3><h3 id="6-9-2-枚举类入门"><a href="#6-9-2-枚举类入门" class="headerlink" title="6.9.2 枚举类入门"></a>6.9.2 枚举类入门</h3><p>enum关键字（它与class、interface关键字的地位相同），用以定义枚举类。枚举类是一种特殊的类，它一样可以有自己的成员变量、方法，可以实现一个或多个接口，也可以定义自己的构造器。一个Java源文件中最多只能定义一个public访问权限的枚举类，且该Java源文件也必须和该枚举类的类名相同。</p>
<p>但枚举类终究不是普通类，它与普通类有如下简单区别。</p>
<ul>
<li>枚举类可以实现一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，而不是默认继承Object类，因此枚举类不能显示继承其他父类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li>
<li>使用enum定义、非抽象的枚举类默认会使用final修饰，因此枚举类不能派生子类。</li>
<li>枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。</li>
<li>枚举类的所有实例必须在枚举类的第一行显示列出，否则这个枚举类永远不能产生实例。列出这些实例时，系统会自动添加public static final修饰，无须程序员显示添加。</li>
</ul>
<p>枚举类默认提供一个values()方法，该方法可以很方便地遍历所有枚举值。</p>
<p>所有的枚举类都继承了java.lang.Enum类，所有枚举类都可以直接使用java.lang.Enum类中所包含的方法。java.lang.Enum类中提供了如下几个方法。</p>
<ul>
<li>int compareTo(E o)：该方法用于与指定枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例进行比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；如果该枚举对象位于指定枚举对象之前，则返回负整数，否则返回零。</li>
<li>String name()：返回此枚举实例的名称，这个名称就是定义枚举类时列出的所有枚举之一。与此方法相比，大多数程序员应该优先考虑使用toString()方法，因为toString()方法返回更加用户友好的名称。</li>
<li>int ordinal()：返回枚举值在枚举类中的索引值（就是枚举值在枚举声明中的位置，第一个枚举值的索引值为零）。</li>
<li>String toString()：返回枚举常量的名称，与name方法相似，但toString()方法更常用。</li>
<li>public static <t extends="" enum<t="">&gt; T valueOf()(class<t> enumType, String name)：这是一个静态方法，用于返回指定枚举类中指定名称的枚举值。名称必须与在该枚举类中声明值时所用的标识符完全匹配，不允许使用额外的空白字符。</t></t></li>
</ul>
<h3 id="6-9-3-枚举类的成员变量、方法和构造器"><a href="#6-9-3-枚举类的成员变量、方法和构造器" class="headerlink" title="6.9.3 枚举类的成员变量、方法和构造器"></a>6.9.3 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种类，只是它是一种特殊的类，因此它一样可以定义成员变量、方法和构造器。</p>
<h3 id="6-9-4-实现接口的枚举类"><a href="#6-9-4-实现接口的枚举类" class="headerlink" title="6.9.4 实现接口的枚举类"></a>6.9.4 实现接口的枚举类</h3><p>枚举类可以实现一个或多个接口。与普通类实现一个或多个接口完全一样，枚举类实现一个或多个接口时，也需要实现该接口所包含的方法。</p>
<h3 id="6-9-5-包含抽象方法的枚举类"><a href="#6-9-5-包含抽象方法的枚举类" class="headerlink" title="6.9.5 包含抽象方法的枚举类"></a>6.9.5 包含抽象方法的枚举类</h3><p>枚举类里定义抽象方法时不能使用abstract关键字将枚举定义成抽象类（因为系统会自动为它添加abstract关键字），但枚举类需要显式创建枚举值，而不是作为父类，所以定义每个枚举值时必须为抽象方法提供实现，否则将出现编译错误。</p>
<h3 id="对象与垃圾回收"><a href="#对象与垃圾回收" class="headerlink" title="对象与垃圾回收"></a>对象与垃圾回收</h3><p>当程序创建对象、数组等引用型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何变量引用时，这块内存就变成垃圾，等待垃圾回收机制进行回收。垃圾回收机制有如下特征。</p>
<ul>
<li>垃圾回收机制只负责回收堆内存中的对象，不回收任何物理资源（例如数据库连接、网络IO等资源）。</li>
<li>程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收它所占的内存。</li>
<li>在垃圾回收机制回收对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。</li>
</ul>
<h3 id="6-10-1-对象在内存中的状态"><a href="#6-10-1-对象在内存中的状态" class="headerlink" title="6.10.1 对象在内存中的状态"></a>6.10.1 对象在内存中的状态</h3><p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成如下三种。</p>
<ul>
<li>可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的实例变量和方法。</li>
<li>可恢复状态：如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用所有可恢复状态对象的finalize()方法进行资源清理。如果系统在调用finalize()方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态；否则该对象将进入不可达状态。</li>
<li>不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有使该对象变成可达状态，那么这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li>
</ul>
<p>一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实例变量引用。当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象被其他对象的实例变量引用时，只有当该对象被销毁后，该对象才会进入可恢复状态。</p>
<h3 id="6-10-2-强制垃圾回收"><a href="#6-10-2-强制垃圾回收" class="headerlink" title="6.10.2 强制垃圾回收"></a>6.10.2 强制垃圾回收</h3><p>当一个对象失去引用后，系统何时调用它的finalize()方法对它进行资源清理，何时它会变成不可达状态，系统何时回收它所占有的内存，对于程序完全透明。程序只能控制一个对象何时不再被任何引用变量引用，绝不能控制它何时被回收。</p>
<p>程序无法精确控制Java垃圾回收的时机，但依然可以强制系统进行垃圾回收——这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。大部分时候，程序强制系统垃圾回收后总会有一些效果。强制系统垃圾回收有如下两种方式。</p>
<ul>
<li>调用System类的get()静态方法：System.gc()。</li>
<li>调用runtime对象的gc()实例方法：Runtime.getRuntime().gc()。</li>
</ul>
<p>下面程序创建了4个匿名对象，每个匿名对象创建之后即进入可恢复状态，等待系统回收，但知道程序退出，系统依然不会回收该资源。</p>
<h3 id="6-10-3-finalize方法"><a href="#6-10-3-finalize方法" class="headerlink" title="6.10.3 finalize方法"></a>6.10.3 finalize方法</h3><p>在垃圾回收机制回收某个对象所占的内存之前，通常要求程序调用适当的方法来清理资源，在没有明确指定清理资源的情况下，Java提供了默认机制来清理该对象的资源，这个机制就是finalize()方法。该方法是定义在Object()类里的实例方法，方法原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void finalize() throws Throwable</div></pre></td></tr></table></figure>
<p>当finalize()方法返回后，对象消失，垃圾回收机制开始执行。方法原型中的throws Throwable表示它可以抛出任何类型的异常。</p>
<p>任何Java类都可以重写Object类的finalize()方法，在该方法中清理该对象占用的资源。如果程序终止之前始终没有进行垃圾回收，则不会调用失去引用对象的finalize()方法来清理资源。垃圾回收机制何时调用对象的finalize()方法是完全透明的，只有当程序认为需要更多的额外内存时，垃圾回收机制才会进行垃圾回收。因此，完全有可能出现这样一种情形：某个失去引用的对象只占用了少量内存，而且系统没有产生严重的内存需求，因此垃圾回收机制并没有试图回收该对象所占的资源，所以该对象的finalize()方法也不会得到调用。</p>
<p>finalize()方法有如下4个特点。</p>
<ul>
<li>永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。</li>
<li>finalize()方法何时被调用，是否被调用具有不确定性，不要把fianlize()方法当成一定会被执行的方法。</li>
<li>当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。</li>
<li>当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。</li>
</ul>
<h3 id="6-10-4-对象的软、弱和虚引用"><a href="#6-10-4-对象的软、弱和虚引用" class="headerlink" title="6.10.4 对象的软、弱和虚引用"></a>6.10.4 对象的软、弱和虚引用</h3><p>对大部分对象而言，程序里会有一个引用变量引用该对象，这是最常见的引用方式。除此之外，java.lang.ref包下提供了3个类：SoftReference、PhantomReference和WeakReference，它们分别代表了系统对对象的3种引用方式：软引用、虚引用和弱引用。因此，Java语言对对象的引用有如下4种方式。</p>
<ol>
<li>强引用（StrongReference）<br>这是Java最常见的引用方式。程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象，前面介绍的对象和数组都采用了这种强引用的方式。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。</li>
</ol>
<ol>
<li>软引用（SoftReference）<br>软引用主要通过SoftReference类实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可以使用该对象；当系统存储空间不足时，系统可能回收它。软引用通常用于对内存敏感的程序中。</li>
</ol>
<ol>
<li>弱引用（WeakReference）<br>弱引用通过WeakReference类实现，若引用和软引用很像，但若引用的引用级别更低。对于只有若引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收——正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。</li>
</ol>
<ol>
<li>虚引用（PhantomReference）</li>
</ol>
<p>虚引用通过PhantomReference类实现，虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>引用队列由java.lang.ref.ReferenceQueue类表示，它用于保存被回收后对象的引用。当联合使用软引用、弱引用和引用队列时，系统在回收被引用的对象之后，将把被回收对象对应的引用添加到关联的引用队列中。与软引用和弱引用不同的是，虚引用在对象被释放之前，将把它对应的虚引用添加到它关联的引用队列中，这使得可以在对象被回收之前采取行动。</p>
<p>软引用和弱引用可以单独使用，但虚引用不能单独使用，单独使用的虚引用没有太大的意义。虚引用的主要作用是跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否包含了该虚引用，从而了解虚引用所引用的对象是即将被回收。</p>
<h2 id="6-11-修饰符的使用范围"><a href="#6-11-修饰符的使用范围" class="headerlink" title="6.11 修饰符的使用范围"></a>6.11 修饰符的使用范围</h2><h2 id="6-12-使用JAR文件"><a href="#6-12-使用JAR文件" class="headerlink" title="6.12 使用JAR文件"></a>6.12 使用JAR文件</h2><p>JAR文件的全称是Java Archive File，意思是Java档案文件。通常JAR文件是一种压缩文件，与常见的ZIP压缩文件兼容，通常也被称为JAR包。JAR文件与ZIP文件的区别就是在JAR文件中默认包含了一个名为META-INF/MANIFEST.MF的清单文件，这个清单文件是在生成JAR文件时由系统自动创建的。</p>
<p>当开发了一个应用程序后，这个应用程序包含了很多类，如果需要把这个应用程序提供给别人使用，通常会将这些类文件打包成一个JAR文件，把这个JAR文件提供给别人使用。只要别人在系统的CLASSPATH环境变量中添加这个JAR文件，则Java虚拟机就可以自动在内存中解压这个JAR包，把这个JAR文件当成一个路径，在这个路径中查找</p>
<p>使用JAR文件有以下好处。</p>
<ul>
<li>安全。能够对JAR文件进行数字签名，只能够识别数字签名的用户使用里面的东西。</li>
<li>加快下载速度。在网上使用Applet时，如果存在多个文件而不打包，为了能够把每个文件都下载到客户端，需要为每个文件单独建立一个HTTP连接，这是非常耗时的工作。将这些文件压缩成一个JAR包，只要建立一次HTTP连接就能够一次下载所有的文件。</li>
<li>压缩。使文件变小，JAR的压缩机制和ZIP完全相同。</li>
<li>包封装。能够让JAR包里面的文件依赖于统一版本的类文件。</li>
<li>可移植性。JAR包作为内嵌在Java平台内部处理的标准，能够在各种平台上直接使用。</li>
</ul>
<p>把一个JAR文件添加到系统的CLASSPATH环境变量中后，Java将会把这个JAR文件当成一个路径来处理。实际上JAR文件就是一个路径，JAR文件通常使用jar命令压缩而成，当使用jar命令压缩生成JAR文件时，可以把一个或多个路径全部压缩成一个JAR文件。</p>
<h3 id="6-12-1-jar命令详解"><a href="#6-12-1-jar命令详解" class="headerlink" title="6.12.1 jar命令详解"></a>6.12.1 jar命令详解</h3><p>jar是随JDK自动安装的，在JDK安装目录下的bin目录中。运行它需要用到JDK安装目录下lib目录中的tools.jar文件，通常系统会自动加载tools.jar，无须显式设置。</p>
<ol>
<li>创建JAR文件：jar cf test.jar test</li>
</ol>
<p>该命令没有显示压缩过程，执行结果是当前路径下的test路径下的全部内容生成一个test.jar文件。如果当前目录中已经存在test.jar文件，那么该文件将被覆盖。</p>
<ol>
<li>创建JAR文件，并显示压缩过程：jar cvf test.jar test</li>
</ol>
<p>该命令的结果与第1个命令相同，但是由于v参数的作用，显示出了打包过程。</p>
<ol>
<li>不使用清单文件：jar cvfM test.jar test</li>
</ol>
<p>该命令的结果与第2个命令类似，其中M选项表明不生成清单文件。因此生成的test.jar中没有包含META-MANIFEST.MF文件，打包过程的信息也略有差别。</p>
<ol>
<li>自定义清单文件内容：jar cvfm test.jar manifest.mf test</li>
</ol>
<p>运行结果与第2个命令相似，显示信息也相同，其中m选项指定读取用户清单文件信息。因此在生成的JAR包中清单文件META-INF/MANIFEST.MF的内容有所不同，它会在原有清单文件基础上增加MANIFEST.MF文件的内容。</p>
<p>当开发者向MANIFEST.MF清单文件中增加自己的内容时，就需要借助于自己的清单文件了，清单文件只是一个普通的文本文件，使用记事本编辑即可。清单文件的内容由如下格式的多个key-value对组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key:&lt;空格&gt;value</div></pre></td></tr></table></figure>
<p>清单文件的内容格式要求如下。</p>
<ul>
<li>每行只能定义一个key-value对，每行的key-value对之前不能有空格，即key-value对必须顶格写。</li>
<li>每组key-value对之间以“: ”（英文冒号后紧跟一个英文空格）分隔，少了冒号或者空格都是错误的。</li>
<li>文件开头不能有空行。</li>
<li>文件必须以一个空行结束。</li>
</ul>
<p>可以将上面文件保存在任意位置，以任意文件名存放。例如将上面文件保存在当前路径下，文件名为a.txt。使用如下命令即可将清单文件中的key-value对提取到META-INF/MANIFEST.MF文件中。</p>
<p>jar cvfm test.jar a.txt test</p>
<ol>
<li>查看JAR包内容：jar tf test.jar</li>
</ol>
<p>在test.jar文件已经存在的前提下，使用此命令可以查看test.jar中的内容。</p>
<ol>
<li><p>查看JAR包详细内容：jar tvf test.jar</p>
</li>
<li><p>解压缩：jar xf test.jar</p>
</li>
</ol>
<ol>
<li>带提示信息解压缩：jar xvf test.jar</li>
</ol>
<ol>
<li>更新JAR文件：jar uf test.jar Hello.class</li>
</ol>
<ol>
<li>更新时显示详细信息：jar uvf test.jar Hello.class</li>
</ol>
<h2 id="6-12-创建可执行的JAR包"><a href="#6-12-创建可执行的JAR包" class="headerlink" title="6.12 创建可执行的JAR包"></a>6.12 创建可执行的JAR包</h2><p>当一个应用程序开发成功后，大致有如下三种发布方式。</p>
<ul>
<li>使用平台相关的编译器将整个应用编译成平台相关的可执行性文件。这种方式常常需要第三方编译器的支持，而且编译生成的可执行文件丧失了跨平台特性，甚至可能有一定的性能下降。</li>
<li>为应用程序编辑一个批处理文件。</li>
<li>将一个应用程序制作成可执行的JAR包，通过JAR包来发布应用程序。</li>
</ul>
<p>把应用程序压缩成JAR包发布是比较典型的做法。</p>
<p>创建可执行的JAR包的关键在于：让javaw命令知道JAR包中哪个类是主类，javaw命令可以通过运行该主类来运行程序。</p>
<p>jar命令有一个-e选项，该选项指定JAR包中作为程序入口的主类的类名。因此，制作一个可执行的JAR包只要增加-e选项即可。</p>
<p>运行上面的JAR包有两种方式。</p>
<ul>
<li>使用java命令，使用java运行时的语法是：java -jar test.jar。</li>
<li>使用javaw命令，使用javaw运行时的语法是：javaw test.jar。</li>
</ul>
<p>当创建JAR包时，所有的类都必须放在与包结构对应的目录结构中。</p>
<h3 id="6-12-3-关于JAR包的技巧"><a href="#6-12-3-关于JAR包的技巧" class="headerlink" title="6.12.3 关于JAR包的技巧"></a>6.12.3 关于JAR包的技巧</h3><h2 id="6-13-本章小结"><a href="#6-13-本章小结" class="headerlink" title="6.13 本章小结"></a>6.13 本章小结</h2><h1 id="第7章-Java基础类库"><a href="#第7章-Java基础类库" class="headerlink" title="第7章 Java基础类库"></a>第7章 Java基础类库</h1><h2 id="7-1-与用户互动"><a href="#7-1-与用户互动" class="headerlink" title="7.1 与用户互动"></a>7.1 与用户互动</h2><h3 id="7-1-1-运行Java程序的参数"><a href="#7-1-1-运行Java程序的参数" class="headerlink" title="7.1.1 运行Java程序的参数"></a>7.1.1 运行Java程序的参数</h3><h3 id="7-1-2-使用Scanner获取键盘输入"><a href="#7-1-2-使用Scanner获取键盘输入" class="headerlink" title="7.1.2 使用Scanner获取键盘输入"></a>7.1.2 使用Scanner获取键盘输入</h3><p>使用Scanner类可以很方便地获取用户的键盘输入，Scanner是一个基于正则表达式的文本扫描器，它可以从文件、输入流、字符串中解析出基本类型值和字符串值。Scanner类提供了多个构造器，不同的构造器可以接收文件、输入流、字符串作为数据源，用于从文件、输入流、字符串中解析数据。</p>
<p>Scanner主要提供了两个方法来扫描输入。</p>
<ul>
<li>hasNetXxx()：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。</li>
<li>NetXxx()：获取下一个输入项。Xxx的含义与前一个方法中的Xxx相同。</li>
</ul>
<p>在默认情况下，Scanner使用空白（包括空格、Tab空白、回车）作为输入项之间的分隔符。</p>
<h2 id="7-2-系统相关"><a href="#7-2-系统相关" class="headerlink" title="7.2 系统相关"></a>7.2 系统相关</h2><p>Java程序在不同操作系统上运行时，可能需要取得平台相关的属性，或者调用平台命令来完成特定功能。Java提供了System类和Runtime类来与程序运行平台进行交互。</p>
<h3 id="7-2-1-System类"><a href="#7-2-1-System类" class="headerlink" title="7.2.1 System类"></a>7.2.1 System类</h3><p>System类代表当前Java程序的运行平台，程序不能创建System类的对象，System类提供了一些类变量和类方法，允许直接通过System类来调用这些类变量和类方法。</p>
<p>System类提供了代表标准输入、标准输出和错误输出的类变量，并提供了一些静态方法用于访问环境变量、系统属性的方法，还提供了加载文件和动态链接库的方法。</p>
<p>加载文件和动态链接库主要对native方法有用，对于一些特殊的功能（如访问操作系统底层硬件设备等）Java程序无法实现，必须借助C语言来完成，此时需要使用C语言为Java方法提供实现。其实现步骤如下：</p>
<ol>
<li>Java程序中声明native修饰的方法，类似于abstract方法，只有方法签名，没有实现。编译该Java程序，生成一个class文件。</li>
<li>用java编译第1步生成的class文件，将产生一个.h文件。</li>
<li>写一个.cpp文件实现native方法，这一步需要包含第2步产生的.h文件（这个.h文件中又包含了JDK自带的jni.h文件）。</li>
<li>将第3步的.cpp文件编译成动态链接库文件。</li>
<li>在Java中用System类的loadLiabrary..()方法或Runtime类的loadLiabrary()方法加载第4步产生的动态链接库文件，Java程序中就可以调用这个native方法了。</li>
</ol>
<h3 id="7-2-2-Runtime类"><a href="#7-2-2-Runtime类" class="headerlink" title="7.2.2 Runtime类"></a>7.2.2 Runtime类</h3><p>Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应的Runtime实例，应用程序通过对该对象与其运行时环境相连。应用程序不能创建自己的Runtime实例，但可以通过getRuntime()方法获取与之关联的Runtime对象。</p>
<p>与System类似的是，Runtime类也提供了gc()方法和runFinalization()方法来通知系统进行垃圾回收、清理系统资源，并提供load(String filename)和loadLiabrary(String libname)方法来加载文件和动态链接库。</p>
<p>Runtime类代表Java程序的运行时环境，可以访问JVM的相关信息，如处理器数量、内存信息等。</p>
<h2 id="7-3-常用类"><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2><h3 id="7-3-1-Object类"><a href="#7-3-1-Object类" class="headerlink" title="7.3.1 Object类"></a>7.3.1 Object类</h3><p>Object类是所有类、数组、枚举类的父类，Java允许把任何类型的对象赋给Object类型的变量。当定义一个类时没有使用extends关键字为它显示指定父类，则该类默认继承Object父类。</p>
<p>因为所有的Java类都是Object类的子类，所以任何Java对象都可以调用Object类的方法。Object类提供了如下几个常用方法。</p>
<ul>
<li>boolean equals(Object obj)：判断指定对象与该对象是否相等。此处相等的标准是，两个对象是同一个对象，因此该equals()方法通常没有太大的实用价值。</li>
<li>protected void finalize()：当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。</li>
<li>Class&lt;?&gt;getClass()：返回该对象的运行时类。</li>
<li>int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算机（即与System.identityHashCode(Object x)方法的计算结果相同）。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算HashCode()方法值。</li>
<li>String toString()：返回该对象的字符串表示，当程序用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回”运行时类名@十六进制hashCode值“格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以描述该对象信息的字符串。</li>
</ul>
<p>除此之外，Object类还提供了wait()、notify()、notifyAll()几个方法，通过这几个方法可以控制线程的暂停和运行。</p>
<p>Java还提供了一个protected修饰的clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于Object类提供的clone()方法使用了protected修饰，因此该方法只能被子类重写或调用。</p>
<p>自定义类实现“克隆”的步骤如下。</p>
<ol>
<li>定义类实现Cloneable接口。这是一个标记性的接口，实现该接口的对象可以实现“自我克隆”，接口里没有定义任何方法。</li>
<li>自定义类实现自己的clone()方法。</li>
<li>实现clone()方法时通过super.clone()：调用Object实现的clone()方法来得到该对象的副本，并返回该副本。</li>
</ol>
<p>需要指出的是，Object类的clone()方法虽然简单、易用，但它只是一种“浅克隆”——它只克隆该对象的所有成员变量值，不会对引用类型的成员变量值所引用的对象进行克隆。如果开发者需要对对象进行“深克隆”，则需要开发者自己进行“递归”克隆，保证所有引用类型的成员变量值所引用的对象都被复制了。</p>
<h3 id="7-3-2-Java-7-新增的Objects类"><a href="#7-3-2-Java-7-新增的Objects类" class="headerlink" title="7.3.2 Java 7 新增的Objects类"></a>7.3.2 Java 7 新增的Objects类</h3><h3 id="7-3-3-String、StringBuffer和StringBuilder类"><a href="#7-3-3-String、StringBuffer和StringBuilder类" class="headerlink" title="7.3.3 String、StringBuffer和StringBuilder类"></a>7.3.3 String、StringBuffer和StringBuilder类</h3><p>字符串就是一连串的字符序列，Java提供了String和StringBuffer两个类来封装字符串，并提供了一系列方法来操作字符串对象。</p>
<p>String类是不可改变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p>
<p>StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p>
<p>StringBuilder类代表字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。因此在通常情况下，StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。因此通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用StringBuilder类。</p>
<p>String、StringBuilder、StringBuffer都实现了CharSequence接口，因此CharSequence可认为是一个字符串的协议接口。</p>
<p>String类提供了大量构造器来创建String对象，其中如下几个有特殊用途。</p>
<ul>
<li>String()：创建一个包含0个字符串的String对象（并不是返回null）。</li>
<li>String(byte[] bytes, Charset charset)：使用指定的字符集将指定的byte[]数组解码成一个新的String对象。</li>
<li>String(byte[] bytes, int offset, int length)：使用平台的默认字符集将指定的byte[]数组从offset开始、长度为count的字符元素连缀成字符串。</li>
<li>String(String original)：根据StringBuffer对象来创建的String对象。也就是说新创建的String对象是该参数字符串的副本。</li>
<li>String(StringBuffer buffer)：根据StringBuffer对象创建对应的String对象。</li>
</ul>
<p>String对象也提供了大量方法来操作字符串对象。</p>
<ul>
<li>charAt(int index)：获取字符串中指定位置的字符。其中，参数index指的是字符串的序数，字符串序数从0开始到length()-1。</li>
<li>int compareTo(String anotherString)：比较两个字符串的大小。如果两个字符串序列序列相等，则返回0；不相等时，从两个字符串第0个字符开始比较，返回第一个不相等的字符差。另一种情况，较长字符串的前面部分恰巧是较短的字符串，则返回它们的长度差。</li>
<li>String concat(String str)：将该String对象与str连接在一起。与Java提供的字符串连接运算符“+”的功能相同。</li>
<li>boolean contentEquals(StringBuffer sb)：将该String对象与StringBuffer对象sb进行比较，当它们包含的字符串序列相同时返回true。</li>
<li>static String copyValueOf(char[] data)：将字符数组连缀成字符串，与String(char[] content)构造器的功能相同。</li>
<li>static String copyValueOf(char[] data, int offset, int count)：将char数组的子数组中的元素连缀成字符串，与String(char[] valuek, int offset, int count)构造器的功能相同。</li>
<li>boolean endWith(String suffix)：返回String对象是否以suffix结尾。</li>
<li>boolean equals(Object anObject)：将该字符串与指定对象比较，如果二者包含的字符串序列相等，则返回true；否则返回false。</li>
<li>boolean equalsIgnoreCase(String str)：与前一个方法基本类似，只是忽略了字符的大小写。</li>
<li>byte[] getBytes()：将该String对象转换成byte数组。</li>
<li>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：该方法将字符串中从srcBegin开始，到srcEnd结束的字符复制到dst字符数组中，其中dstBegin为目标字符数组的起始复制位置。</li>
<li>int indexOf(int ch)：找出ch字符在字符串中第一次出现的位置。</li>
<li>int indexOf(int ch, int fromIndex)：找出ch字符在该字符串中第一次出现的位置。</li>
<li>int indexOf(String str)：找出str子字符串中第一次出现的位置。</li>
<li>int indexOf(String str, int fromIndex)：找出str子字符串在该字符串中从fromIndex开始后第一次出现的位置。</li>
<li>int lastIndexOf(int ch)：找出ch字符在该字符串中最后一次出现的位置。</li>
<li>int lastIndexOf(int ch, int fromIndex)：找出ch字符在该字符串中从fromIndex开始后最后一次出现的位置。</li>
<li>int lastIndexOf(String str, int fromIndex)：找出str子字String符串在该字符串中从fromIndex开始后最后一次出现的位置。</li>
<li>int length()：返回当前字符串长度。</li>
<li>String replace(char oldChar, char newChar)：将字符串中的第一个oldChar替换成newChar。</li>
<li>boolean startsWith(String prefix, int offset)：该String对象从tooffset位置算起，是否以prefix开始。</li>
<li>String substring(int beginIndex)：获取从beginIndex位置开始到结束的子字符串。</li>
<li>String substring(int beginIndex, int endIndex)：获取从beginIndex位置开始到endIndex位置的子字符串。</li>
<li>char[] toCharArray()：将该Strinig对象转换成char数组。</li>
<li>String toLowerCase()：将字符串转换成小写。</li>
<li>String toUpperCase()：将字符串转换成大写。</li>
<li>static String valueOf(X x)：一系列用于将基本类型值转换为String对象的方法。</li>
</ul>
<h3 id="7-3-4-Math类"><a href="#7-3-4-Math类" class="headerlink" title="7.3.4 Math类"></a>7.3.4 Math类</h3><h3 id="7-3-5-Java-7-的ThreadLocalRandom与Random"><a href="#7-3-5-Java-7-的ThreadLocalRandom与Random" class="headerlink" title="7.3.5 Java 7 的ThreadLocalRandom与Random"></a>7.3.5 Java 7 的ThreadLocalRandom与Random</h3><h3 id="7-3-6-BigDecimal类"><a href="#7-3-6-BigDecimal类" class="headerlink" title="7.3.6 BigDecimal类"></a>7.3.6 BigDecimal类</h3><h2 id="7-4-Java-8-的日期、时间类"><a href="#7-4-Java-8-的日期、时间类" class="headerlink" title="7.4 Java 8 的日期、时间类"></a>7.4 Java 8 的日期、时间类</h2><h2 id="7-5-正则表达式"><a href="#7-5-正则表达式" class="headerlink" title="7.5 正则表达式"></a>7.5 正则表达式</h2><h3 id="7-5-1-创建正则表达式"><a href="#7-5-1-创建正则表达式" class="headerlink" title="7.5.1 创建正则表达式"></a>7.5.1 创建正则表达式</h3><p>正则表达式就是一个用于匹配字符串的模板，可以匹配一批字符串，所以创建正则表达式就是创建一个特殊的字符串。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/28/like/" rel="next" title="like">
                <i class="fa fa-chevron-left"></i> like
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="William Qiu" />
          <p class="site-author-name" itemprop="name">William Qiu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-数据类型和运算符"><span class="nav-number">1.</span> <span class="nav-text">第3章 数据类型和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-标识符和关键字"><span class="nav-number">1.1.</span> <span class="nav-text">3.2 标识符和关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-流程控制与数组"><span class="nav-number">2.</span> <span class="nav-text">第4章 流程控制与数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-5-数组类型"><span class="nav-number">3.</span> <span class="nav-text">4.5 数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-理解数组：数组也是一种类型"><span class="nav-number">3.0.1.</span> <span class="nav-text">4.5.1 理解数组：数组也是一种类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-定义数组"><span class="nav-number">3.0.2.</span> <span class="nav-text">4.5.2 定义数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-数组的初始化"><span class="nav-number">3.0.3.</span> <span class="nav-text">4.5.3 数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-使用数组"><span class="nav-number">3.0.4.</span> <span class="nav-text">4.5.4 使用数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5-foreach循环"><span class="nav-number">3.0.5.</span> <span class="nav-text">4.5.5 foreach循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-6-深入数组"><span class="nav-number">4.</span> <span class="nav-text">4.6 深入数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-内存中的数组"><span class="nav-number">4.0.1.</span> <span class="nav-text">4.6.1 内存中的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-基本类型数组的初始化"><span class="nav-number">4.0.2.</span> <span class="nav-text">4.6.2 基本类型数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-引用类型数组的初始化"><span class="nav-number">4.0.3.</span> <span class="nav-text">4.6.3 引用类型数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-4-没有多维数组"><span class="nav-number">4.0.4.</span> <span class="nav-text">4.6.4 没有多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-5-Java-8-增强的工具类：Arrays"><span class="nav-number">4.0.5.</span> <span class="nav-text">4.6.5 Java 8 增强的工具类：Arrays</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-面向对象（上）"><span class="nav-number">5.</span> <span class="nav-text">第5章 面向对象（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-类和对象"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-对象的产生和使用"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.2 对象的产生和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-对象、引用和指针"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.3 对象、引用和指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-对象的this引用"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.4 对象的this引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-方法详解"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-方法的所属性"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 方法的所属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2方法的参数传递机制"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2方法的参数传递机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-形参个数可变的方法"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 形参个数可变的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-递归方法"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4 递归方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-方法重载"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.5 方法重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-成员变量和局部变量"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 成员变量和局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-成员变量和局部变量"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 成员变量和局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-成员变量的初始化和内存中的运行机制"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 成员变量的初始化和内存中的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-局部变量的初始化和内存中的运行机制"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 局部变量的初始化和内存中的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-变量的使用规则"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 变量的使用规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-隐藏和封装"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 隐藏和封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-理解封装"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 理解封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-访问控制符"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 访问控制符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-3-package、import和import-static"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.4.3 package、import和import static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-4-Java的常用包"><span class="nav-number">5.4.4.</span> <span class="nav-text">5.4.4 Java的常用包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-深入构造器"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 深入构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-使用构造器执行初始化"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1 使用构造器执行初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-构造器重载"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2 构造器重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-类的继承"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 类的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-继承的特点"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1 继承的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2-重写父类的方法"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2 重写父类的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-3-super限定"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3 super限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-4-调用父类构造器"><span class="nav-number">5.6.4.</span> <span class="nav-text">5.6.4 调用父类构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-多态"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-1-多态性"><span class="nav-number">5.7.1.</span> <span class="nav-text">5.7.1 多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-2引用变量的强制类型转换"><span class="nav-number">5.7.2.</span> <span class="nav-text">5.7.2引用变量的强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instatof运算符"><span class="nav-number">5.7.3.</span> <span class="nav-text">instatof运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-继承与组合"><span class="nav-number">5.8.</span> <span class="nav-text">5.8 继承与组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-2-利用组合实现复用"><span class="nav-number">5.8.1.</span> <span class="nav-text">5.8.2 利用组合实现复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-初始化块"><span class="nav-number">5.9.</span> <span class="nav-text">5.9 初始化块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-1-使用初始化块"><span class="nav-number">5.9.1.</span> <span class="nav-text">5.9.1 使用初始化块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-2-初始化块和构造器"><span class="nav-number">5.9.2.</span> <span class="nav-text">5.9.2 初始化块和构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-3-静态初始化块"><span class="nav-number">5.9.3.</span> <span class="nav-text">5.9.3 静态初始化块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-本章小结"><span class="nav-number">5.10.</span> <span class="nav-text">5.10 本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-面向对象（下）"><span class="nav-number">6.</span> <span class="nav-text">第6章 面向对象（下）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Java-8增强的包装类。"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Java 8增强的包装类。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-处理对象"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 处理对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-打印对象和toString方法"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 打印对象和toString方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-和equals方法"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 ==和equals方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-类成员"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 类成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-理解类成员"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 理解类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-单例（Singleton）类"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 单例（Singleton）类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-final修饰符"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 final修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-final成员变量"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 final成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-final局部变量"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 final局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-final修饰基本类型变量和引用类型变量的区别"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3 final修饰基本类型变量和引用类型变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-可执行“宏替换”的final变量"><span class="nav-number">6.4.4.</span> <span class="nav-text">6.4.4 可执行“宏替换”的final变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-final方法"><span class="nav-number">6.4.5.</span> <span class="nav-text">6.4.5 final方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-7-不可变类"><span class="nav-number">6.4.6.</span> <span class="nav-text">6.4.7 不可变类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-8-缓存实例的不可变类"><span class="nav-number">6.4.7.</span> <span class="nav-text">6.4.8 缓存实例的不可变类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-抽象类"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-抽象方法和抽象类"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 抽象方法和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-抽象类的作用"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 抽象类的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Java-8改进的接口"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 Java 8改进的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-接口的概念"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.6.1 接口的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-Java8中接口的定义"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.6.2 Java8中接口的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-接口的继承"><span class="nav-number">6.6.3.</span> <span class="nav-text">6.6.3 接口的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-4-使用接口"><span class="nav-number">6.6.4.</span> <span class="nav-text">6.6.4 使用接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-5-接口和抽象类"><span class="nav-number">6.6.5.</span> <span class="nav-text">6.6.5 接口和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-6-面向接口编程"><span class="nav-number">6.6.6.</span> <span class="nav-text">6.6.6 面向接口编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-内部类"><span class="nav-number">6.7.</span> <span class="nav-text">6.7 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-非静态内部类"><span class="nav-number">6.7.1.</span> <span class="nav-text">6.7.1 非静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-静态内部类"><span class="nav-number">6.7.2.</span> <span class="nav-text">6.7.2 静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-使用内部类"><span class="nav-number">6.7.3.</span> <span class="nav-text">6.7.3 使用内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-4-局部内部类"><span class="nav-number">6.7.4.</span> <span class="nav-text">6.7.4 局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-5-Java-8-改进的匿名内部类"><span class="nav-number">6.7.5.</span> <span class="nav-text">6.7.5 Java 8 改进的匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-Java-8新增的Lambda表达式"><span class="nav-number">6.8.</span> <span class="nav-text">6.8 Java 8新增的Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-1-Lambda表达式入门"><span class="nav-number">6.8.1.</span> <span class="nav-text">6.8.1 Lambda表达式入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-2-Lambda表达式与函数式接口"><span class="nav-number">6.8.2.</span> <span class="nav-text">6.8.2 Lambda表达式与函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-3-方法引用与构造器引用"><span class="nav-number">6.8.3.</span> <span class="nav-text">6.8.3 方法引用与构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-4-Lambda表达式与匿名内部类的联系和区别"><span class="nav-number">6.8.4.</span> <span class="nav-text">6.8.4 Lambda表达式与匿名内部类的联系和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-5-使用Lambda表达式调用Arrays的类方法"><span class="nav-number">6.8.5.</span> <span class="nav-text">6.8.5 使用Lambda表达式调用Arrays的类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9-枚举类"><span class="nav-number">6.9.</span> <span class="nav-text">6.9 枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-1-手动实现枚举类"><span class="nav-number">6.9.1.</span> <span class="nav-text">6.9.1 手动实现枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-2-枚举类入门"><span class="nav-number">6.9.2.</span> <span class="nav-text">6.9.2 枚举类入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-3-枚举类的成员变量、方法和构造器"><span class="nav-number">6.9.3.</span> <span class="nav-text">6.9.3 枚举类的成员变量、方法和构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-4-实现接口的枚举类"><span class="nav-number">6.9.4.</span> <span class="nav-text">6.9.4 实现接口的枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-5-包含抽象方法的枚举类"><span class="nav-number">6.9.5.</span> <span class="nav-text">6.9.5 包含抽象方法的枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象与垃圾回收"><span class="nav-number">6.9.6.</span> <span class="nav-text">对象与垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-1-对象在内存中的状态"><span class="nav-number">6.9.7.</span> <span class="nav-text">6.10.1 对象在内存中的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-2-强制垃圾回收"><span class="nav-number">6.9.8.</span> <span class="nav-text">6.10.2 强制垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-3-finalize方法"><span class="nav-number">6.9.9.</span> <span class="nav-text">6.10.3 finalize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-4-对象的软、弱和虚引用"><span class="nav-number">6.9.10.</span> <span class="nav-text">6.10.4 对象的软、弱和虚引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-11-修饰符的使用范围"><span class="nav-number">6.10.</span> <span class="nav-text">6.11 修饰符的使用范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-12-使用JAR文件"><span class="nav-number">6.11.</span> <span class="nav-text">6.12 使用JAR文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-12-1-jar命令详解"><span class="nav-number">6.11.1.</span> <span class="nav-text">6.12.1 jar命令详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-12-创建可执行的JAR包"><span class="nav-number">6.12.</span> <span class="nav-text">6.12 创建可执行的JAR包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-12-3-关于JAR包的技巧"><span class="nav-number">6.12.1.</span> <span class="nav-text">6.12.3 关于JAR包的技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-13-本章小结"><span class="nav-number">6.13.</span> <span class="nav-text">6.13 本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-Java基础类库"><span class="nav-number">7.</span> <span class="nav-text">第7章 Java基础类库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-与用户互动"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 与用户互动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-运行Java程序的参数"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 运行Java程序的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-使用Scanner获取键盘输入"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 使用Scanner获取键盘输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-系统相关"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 系统相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-System类"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 System类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-Runtime类"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 Runtime类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-常用类"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-Object类"><span class="nav-number">7.3.1.</span> <span class="nav-text">7.3.1 Object类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-Java-7-新增的Objects类"><span class="nav-number">7.3.2.</span> <span class="nav-text">7.3.2 Java 7 新增的Objects类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-String、StringBuffer和StringBuilder类"><span class="nav-number">7.3.3.</span> <span class="nav-text">7.3.3 String、StringBuffer和StringBuilder类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-Math类"><span class="nav-number">7.3.4.</span> <span class="nav-text">7.3.4 Math类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-Java-7-的ThreadLocalRandom与Random"><span class="nav-number">7.3.5.</span> <span class="nav-text">7.3.5 Java 7 的ThreadLocalRandom与Random</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-6-BigDecimal类"><span class="nav-number">7.3.6.</span> <span class="nav-text">7.3.6 BigDecimal类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Java-8-的日期、时间类"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 Java 8 的日期、时间类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-正则表达式"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-创建正则表达式"><span class="nav-number">7.5.1.</span> <span class="nav-text">7.5.1 创建正则表达式</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William Qiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
